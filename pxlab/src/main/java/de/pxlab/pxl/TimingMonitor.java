package de.pxlab.pxl;

import java.awt.Point;

/**
 * A monitor object used to control delay periods by putting the current thread
 * to sleep until it is notified by some other thread.
 * 
 * <p>
 * The central mechanism for PXLab's timing control is contained in class
 * TimingMonitor. The PresentationManager owns a single instance of the
 * TimingMonitor class. Whenever the PresentationManager needs to wait for a
 * timing event it calls the TimingMonitor method waitForTimingEvent(). If any
 * response timer is involved then this method first activates response event
 * listening by calling the method setActiveResponseTiming() of the
 * ResponseManager. This activates all response devices. The
 * waitForTimingEvent() method then stops the currently active thread by calling
 * its wait() method. If there is a clock timer involved then the wait method
 * gets the timer duration as an argument. If no clock timer is involved then
 * wait() without argument is called. Executing the wait() method stops the
 * currently running thread until either the respective duration has passed or
 * some other thread wakes up the TimingMonitor object by calling its notify()
 * method.
 * 
 * <p>
 * After the TimingMonitor object returns from its wait() method and response
 * event listening had been activated it is deactivated again by calling the
 * ResponseManager's setActiveResponseTiming() method with a false argument.
 * This deactivates all response devices. If a clock timer had been involved
 * then the actual timing parameters are stored after the return from wait().
 * 
 * <p>
 * So who is allowed to call the notify() method of the TimingMonitor and thus
 * stop a timing interval? The TimingMonitor has a single method which calls its
 * notify() method: setTimingEvent(). Calling setTimingEvent() wakes up the
 * TimingMonitor event whenever its wait() method had been called. The only
 * existing class which calls setTimingEvent() is the ResponseManager class.
 * 
 * @version 0.6.0
 * @see PresentationManager
 * @see ResponseManager
 */
/*
 * 03/08/01 We use the HiresClock.getTime() method now to measure response and
 * display intervals. Note that one must be careful not to mix
 * System.getTimeMillis() and HiresClock.getTime() since these use different
 * counters and HiresClock.getTime() is not started at any well defined point.
 * 
 * 06/17/02 Added code to detect a spurious response event during clock timer
 * intervals.
 * 
 * 02/14/03 added text input string for serial line
 * 
 * 05/22/03 fixed video sync timing bugs
 * 
 * 06/05/03 removed the TIME_OUT definition and use the one from
 * ResponseCodes.java
 * 
 * 2005/05/02 fixed bug with activeResponseTiming
 * 
 * 2005/06/15 use WaitLock class
 * 
 * 2005/06/18 removed video synchronization code from here
 * 
 * 2005/07/21 store response event position
 * 
 * 2007/02/11 handle polled devices.
 * 
 * 2005/05/22 added keyboard character and key location codes
 */
public class TimingMonitor implements TimerBitCodes {
	/** Contains the time when the timer stop event happened. */
	private long timingEventTime;
	/**
	 * Contains the timer bit code of the timer which controlled the timing
	 * event which stopped the timer.
	 */
	private int timingEventType;
	/**
	 * Contains a code value which was generated by the timing event which
	 * stopped the timer.
	 */
	private int timingEventCode;
	/**
	 * Contains a character code value which was generated by the keyboard
	 * timing event which stopped the timer.
	 */
	private int timingEventCharCode;
	/**
	 * Identifies the key location of the keyboard timing event which stopped
	 * the timer.
	 */
	private int timingEventKeyLocation;
	/** Contains the position of the mouse when the timing event happened. */
	private Point timingEventPosition;
	/**
	 * Contains text which was generated by the timing event which stopped the
	 * timer.
	 */
	private String timingEventText;
	/**
	 * True if a real time clock is used to control the timing interval and the
	 * clock has stopped the timing interval.
	 */
	private boolean clockTimingEvent;
	/**
	 * True if a spurious response event has been detected during the current
	 * clock timer interval. Note that only the first spurious response event
	 * within a single clock interval will be stored.
	 */
	private boolean spuriousResponseEvent;
	private long spuriousResponseEventTime;
	private int spuriousResponseEventType;
	private int spuriousResponseEventCode;
	/** Contains the position of the mouse when the response event happened. */
	private Point spuriousResponseEventPosition;
	private WaitLock waitLock;

	public TimingMonitor() {
		waitLock = new WaitLock();
	}

	/**
	 * Make the current thread sleep until it is notified by some other thread.
	 * This method is called by the PresentationManager class after a display
	 * object has been shown and its timing interval has to be controlled.
	 * 
	 * @param timer
	 *            the timer code of the respective display element timing group.
	 * @param duration
	 *            the intended duration of the respective display element group.
	 * @param useResponseTimer
	 *            is true if the response devices should be activated when
	 *            waiting for the end of the timing interval.
	 * @param responseManager
	 *            the ResponseManager which controls the response devices which
	 *            may have to be activated. Response device activation has to be
	 *            done here since otherwise a concurrent process may set a
	 *            response event before the respective timing event has been
	 *            started.
	 */
	public void waitForTimingEvent(int timer, long duration,
			boolean useResponseTimer, ResponseManager responseManager) {
		// System.out.println("TimingMonitor.waitForTimingEvent() timer=" +
		// timer + ", duration=" + duration);
		spuriousResponseEvent = false;
		clockTimingEvent = true;
		boolean doPolling = false;
		if (useResponseTimer) {
			responseManager.setActiveResponseTiming(true);
			doPolling = responseManager.pollingIsRequired()
					&& ((timer & (XBUTTON_TIMER_BIT | AXIS_TRACKING_BIT)) != 0);
			// if (doPolling)
			// System.out.println("TimingMonitor.waitForTimingEvent() polling is on");
		}
		if ((timer & CLOCK_TIMER_BIT) != 0) {
			// Wait for a clock driven timer signal.
			if (duration > 0L) {
				// Debug.time("wait(" + String.valueOf(duration) + "): ");
				waitLock.waitForNanos(duration, doPolling ? responseManager
						: null);
				// Debug.time("woke up at : ");
			}
		} else {
			// Wait for a response driven timer signal.
			waitLock.waitFor(doPolling ? responseManager : null);
		}
		// Debug.time("Experimental thread woke up:  ");
		if (useResponseTimer) {
			responseManager.setActiveResponseTiming(false);
		}
		if (clockTimingEvent) {
			// In case of a clock timer we have to set the timing
			// event parameters.
			timingEventTime = HiresClock.getTimeNanos();
			timingEventType = CLOCK_TIMER_BIT;
			timingEventCode = ResponseCodes.TIME_OUT;
		}
	}

	/** Stop any waiting period immediately. */
	public void stop() {
		Debug.show(Debug.EVENTS, "TimingMonitor.stop()");
		waitLock.wakeUp();
	}

	/**
	 * Tell the timing monitor that a response timing event with an integer
	 * event code has ocurred. This notifies the thread which put the timing
	 * monitor to sleep and thus stops the waiting period.
	 * 
	 * @param t
	 *            the time when the timing event had been detected.
	 * @param tp
	 *            the type of the timing event. This corresponds to the
	 *            TimerCode of the timer which stopped the timing interval.
	 * @param cd
	 *            response event code which stopped the timing interval.
	 */
	public void setTimingEvent(long t, int tp, int cd) {
		// Debug.timeMsg("Timing event at:              " + t);
		timingEventTime = t;
		timingEventType = tp;
		timingEventCode = cd;
		clockTimingEvent = false;
		// Debug.time("Waking up experimental thread:");
		waitLock.wakeUp();
	}

	/**
	 * Tell the timing monitor that a mouse response timing event with position
	 * data has ocurred. This notifies the thread which put the timing monitor
	 * to sleep and thus stops the waiting period.
	 * 
	 * @param t
	 *            the time when the timing event had been detected.
	 * @param tp
	 *            the type of the timing event. This corresponds to the
	 *            TimerCode of the timer which stopped the timing interval.
	 * @param cd
	 *            response event code which stopped the timing interval.
	 * @param p
	 *            position of the mouse pointer when the event happened.
	 *            Position data are AWT-coordinates relative to the component
	 *            which received the event.
	 */
	public void setTimingEvent(long t, int tp, int cd, Point p) {
		timingEventPosition = p;
		setTimingEvent(t, tp, cd);
	}

	/**
	 * Tell the timing monitor that a keyboard response timing event has
	 * ocurred. This notifies the thread which put the timing monitor to sleep
	 * and thus stops the waiting period.
	 * 
	 * @param t
	 *            the time when the timing event had been detected.
	 * @param tp
	 *            the type of the timing event. This corresponds to the
	 *            TimerCode of the timer which stopped the timing interval.
	 * @param cd
	 *            keyboard key code which stopped the timing interval.
	 * @param charCode
	 *            keyboard key character code which stopped the timing interval.
	 * @param location
	 *            the location of the key on the keyboard which stopped the
	 *            timing interval.
	 */
	public void setTimingEvent(long t, int tp, int cd, int charCode,
			int location) {
		timingEventCharCode = charCode;
		timingEventKeyLocation = location;
		setTimingEvent(t, tp, cd);
	}

	/**
	 * Tell the timing monitor that a response timing event with a string event
	 * code has ocurred. This notifies the thread which put the timing monitor
	 * to sleep and thus stops the waiting period.
	 * 
	 * @param t
	 *            the time when the timing event had been detected.
	 * @param tp
	 *            the type of the timing event. This corresponds to the
	 *            TimerCode of the timer which stopped the timing interval.
	 * @param txt
	 *            text generated by the response event code which stopped the
	 *            timing interval.
	 */
	public void setTimingEvent(long t, int tp, String txt) {
		// Debug.timeMsg("Timing event at:              " + t);
		timingEventTime = t;
		timingEventType = tp;
		timingEventText = txt;
		clockTimingEvent = false;
		waitLock.wakeUp();
	}

	/**
	 * Tell the timing monitor that a response event has been detected during a
	 * waiting period which did not expect a response event to happen. This
	 * event does not affect the timer and does not stop the clock. Also note
	 * that only the first spurious response event will be stored.
	 * 
	 * @param t
	 *            the time when the timing event had been detected.
	 * @param tp
	 *            the type of the timing event. This corresponds to the
	 *            TimerCode of the timer which tried to stop the timing
	 *            interval.
	 * @param cd
	 *            response event code.
	 */
	public void setSpuriousResponseEvent(long t, int tp, int cd) {
		if (!spuriousResponseEvent) {
			spuriousResponseEventTime = t;
			spuriousResponseEventType = tp;
			spuriousResponseEventCode = cd;
			spuriousResponseEvent = true;
		}
	}

	/**
	 * Tell the timing monitor that a mouse response event has been detected
	 * during a waiting period which did not expect a response event to happen.
	 * This event does not affect the timer and does not stop the clock. Also
	 * note that only the first spurious response event will be stored.
	 * 
	 * @param t
	 *            the time when the timing event had been detected.
	 * @param tp
	 *            the type of the timing event. This corresponds to the
	 *            TimerCode of the timer which tried to stop the timing
	 *            interval.
	 * @param cd
	 *            response event code.
	 * @param p
	 *            position of the mouse pointer when the event happened.
	 *            Position data are AWT-coordinates relative to the component
	 *            which received the event.
	 */
	public void setSpuriousResponseEvent(long t, int tp, int cd, Point p) {
		if (!spuriousResponseEvent) {
			spuriousResponseEventPosition = p;
			setSpuriousResponseEvent(t, tp, cd);
		}
	}

	public long getTimingEventTime() {
		return timingEventTime;
	}

	public int getTimingEventType() {
		return timingEventType;
	}

	public int getTimingEventCode() {
		return timingEventCode;
	}

	public int getTimingEventCharCode() {
		return timingEventCharCode;
	}

	public int getTimingEventKeyLocation() {
		return timingEventKeyLocation;
	}

	public Point getTimingEventPosition() {
		return timingEventPosition;
	}

	public String getTimingEventText() {
		return timingEventText;
	}

	/**
	 * Check whether a spurious response event has been detected during the most
	 * recent clock timer interval.
	 */
	public boolean hasSpuriousResponseEvent() {
		return spuriousResponseEvent;
	}

	public long getSpuriousResponseEventTime() {
		return spuriousResponseEventTime;
	}

	public int getSpuriousResponseEventType() {
		return spuriousResponseEventType;
	}

	public int getSpuriousResponseEventCode() {
		return spuriousResponseEventCode;
	}

	public Point getSpuriousResponseEventPosition() {
		return spuriousResponseEventPosition;
	}
}
