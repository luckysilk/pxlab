package de.pxlab.pxl;

import java.awt.*;
import java.awt.event.*;
import java.util.*;
import javax.sound.sampled.AudioFormat;

import de.pxlab.util.StringExt;
import de.pxlab.pxl.sound.VoiceKeyRecorder;

/**
 * Handles events which are related to the timing of display objects.
 * 
 * Primarily this are subject response events. However, this class also manages
 * media events which are generated by media control threads. Thus generally
 * this class handles timing events which are generated by threads other than
 * the main control thread. Subject response events are generated in the event
 * queue thread and mainly correspond to AWT input events from keyboard and
 * mouse. The ResponseManager also handles response events generated by external
 * button boxes connected to the serial port control lines, serial line
 * character input, and events generated by media control threads like media
 * players or sound recorders.
 * 
 * <p>
 * A ResponseManager contains several sources for calling the TimingMonitor's
 * setTimingEvent() method.
 * 
 * @version 0.4.1
 */
/*
 * 
 * 2004/10/01
 * 
 * 2005/05/02 fixed bug with activeResponseTiming
 * 
 * 2005/07/21 store mouse position for mouse responses.
 * 
 * 2006/01/16 call activeDisplay.getAllowTimerStop() immediately before stopping
 * a timer. This allows the active display to control whether it can be stopped
 * or not.
 * 
 * 2006/06/19 media events contain the event type information in the id codes
 * now.
 * 
 * 2007/02/04 added MouseWheelListener
 * 
 * 2007/02/11 added polled devices and SpaceMouse device support.
 * 
 * 2008/02/28 observe VoiceKeyStopImmediately flag when using a voice key.
 */
public class ResponseManager implements MouseListener, MouseMotionListener,
		MouseWheelListener, KeyboardResponseListener, ExternalButtonListener,
		SerialCommunicationListener, SpaceMouseListener, MediaEventListener,
		ResponseController, TimerBitCodes {
	/**
	 * True if response timing is active such that the next response which fits
	 * the expected type of response triggers a notify message to the timing
	 * monitor.
	 */
	private boolean activeResponseTiming = false;
	/**
	 * Starting time in nanoseconds of a response interval which spans multiple
	 * Display objects. This is activated by the
	 * TimerBitCodes.START_RESPONSE_TIMER_BIT. This variable currently is used
	 * here only if a tracking response is on. In this case the mouse tracking
	 * times are relative to the response interval start time.
	 */
	private long responseIntervalStart;

	public void setResponseIntervalStart(long t) {
		responseIntervalStart = t;
	}
	/**
	 * This is set to true if a display is to be presented continuously
	 * (MOUSE_TRACKING_BIT is set) while a mouse button is down. The effect is
	 * to send PointerActivationState(), PointerReleaseState() and
	 * PointerCurrentState() messages to the active display object when the
	 * mouse button goes down, goes up, and the mouse is moved.
	 */
	private boolean mouseTrackingResponse;
	private boolean wheelTrackingResponse;
	private boolean axisTrackingResponse;
	/**
	 * This is set to true if a timing group timer has the bit
	 * STOP_KEY_TIMER_BIT set. This means that this timing group is only stopped
	 * by pressing that key, whose code is defined by ExPar.StopKey. The display
	 * is to be presented repeatedly with keyboard responses until the StopKey
	 * is pressed. Every other than the stop key sends a setKeyResponse()
	 * message to the active display object. Only pressing the stop key notifies
	 * the timing monitor.
	 */
	private boolean repeatUntilStopKey;
	/**
	 * The code for the stop key which stops repeated display presentation.
	 */
	private int stopKey;
	/** True if the active display uses adjustment responses. */
	private boolean adjustmentResponse = false;
	/**
	 * Valid if the current display uses adjustment responses. This object
	 * handles adjustments.
	 */
	private AdjustmentControl adjustmentControl;
	/**
	 * Stores the set of possible response events which are allowed to stop a
	 * response timing interval.
	 */
	private ResponseEventGroup responseEventGroup;
	/**
	 * If true then responses during inactive response timing periods are
	 * collected in the spuriousResponse array. This is activated by the
	 * TimerBitCodes.WATCH_SPURIOUS_RESPONSES_BIT of a timer.
	 */
	private boolean watchSpuriousResponses;
	/**
	 * This is the most recent point in time when spurious response watching had
	 * been started.
	 */
	private long watchSpuriousResponsesStartTime;
	/** Collects responses during inactive response timing periods. */
	private ArrayList spuriousResponse;
	/**
	 * The timing monitor object which is used to synchronize response
	 * collection. The response manager calls the timing monitor's
	 * setTimingEvent() method when a response event or a media event has been
	 * detected. The response manager also watches for spurious response events
	 * and sends these to the timing monitor also.
	 */
	private TimingMonitor timingMonitor;
	/**
	 * The presentation manager which controls this response manager. It is
	 * needed since some mouse tracking and adjustable display objects want to
	 * repaint the active display elements group after certain response events
	 * have been found. These methods call the method
	 * showActiveDisplayElementGroup() to repaint the active timing group of the
	 * active display
	 */
	private PresentationManager presentationManager;
	/**
	 * This is the display object whose timing groups are currently running.
	 * This is needed here since timers which either have the MOUSE_TRACKING_BIT
	 * or the STOP_KEY_TIMER_BIT set have to call the display object after a
	 * non-stopping response event has been detected. These event listener
	 * methods call the setKeyResponse() or the setPointerXXState() methods of
	 * the active display. The active display is set by the presentation manager
	 * calling enableResponseTiming() and sending the active display as an
	 * argument.
	 */
	private Display activeDisplay;
	private ArrayList polledDeviceList = null;
	private SpaceMouse spaceMouse = null;

	/**
	 * Create a response manager which uses the given timing monitor to
	 * synchronize its timing with the respective display events. This
	 * constructor is only called by a constructor of the class
	 * PresentationManager.
	 * 
	 * @param presentationManager
	 *            the presentation manager which controls this response manager.
	 * @param timingMonitor
	 *            the timing monitor which is used for synchronization between
	 *            the display events and the response events.
	 */
	public ResponseManager(PresentationManager presentationManager,
			TimingMonitor timingMonitor) {
		this.presentationManager = presentationManager;
		this.timingMonitor = timingMonitor;
		spuriousResponse = new ArrayList();
		responseEventGroup = new ResponseEventGroup();
		// Just to make sure that high resolution timing is installed.
		HiresClock.getTimeNanos();
	}

	// ----------------------------------------------------------
	// This starts and stops response timing
	// ----------------------------------------------------------
	/**
	 * Define which timing events are allowed to stop the timing interval of the
	 * currently active timing group of the given display object. The timing
	 * events are defined by the timerType argument. This argument is used to
	 * set the group of admissible response events for stopping the given
	 * dispaly object's active timing group. Nonzero flags in the timerType
	 * pattern create a response event mask which is used to decide which types
	 * of response events are able to stop the timer. This method is called by
	 * the PresentationManager class if a display object's timing group requires
	 * a response device or a media thread timer event including a voice key
	 * timer.
	 * 
	 * @param display
	 *            the display object which owns the timing group we are
	 *            currently running.
	 * @param timerType
	 *            timer type bit pattern defining the timing event which we have
	 *            to wait for.
	 * @param activeCodes
	 *            an array of response codes which are allowed to stop response
	 *            timing in case of a response device which has key codes.
	 */
	public void prepareEventTiming(Display display, int timerType,
			int[] activeCodes) {
		activeDisplay = display;
		repeatUntilStopKey = false;
		int deviceMask = 0;
		int directionMask = 0;
		if ((timerType & KEY_TIMER_BIT) != 0)
			deviceMask += KEY_TIMER_BIT;
		if ((timerType & MOUSE_BUTTON_TIMER_BIT) != 0)
			deviceMask += MOUSE_BUTTON_TIMER_BIT;
		if ((timerType & XBUTTON_TIMER_BIT) != 0)
			deviceMask += XBUTTON_TIMER_BIT;
		if ((timerType & SERIAL_LINE_TIMER_BIT) != 0)
			deviceMask += SERIAL_LINE_TIMER_BIT;
		if ((timerType & SYNC_TO_MEDIA_TIMER_BIT) != 0)
			deviceMask += SYNC_TO_MEDIA_TIMER_BIT;
		if ((timerType & END_OF_MEDIA_TIMER_BIT) != 0)
			deviceMask += END_OF_MEDIA_TIMER_BIT;
		if ((timerType & DOWN_TIMER_BIT) != 0)
			directionMask += DOWN_TIMER_BIT;
		if ((timerType & UP_TIMER_BIT) != 0)
			directionMask += UP_TIMER_BIT;
		mouseTrackingResponse = ((timerType & MOUSE_TRACKING_BIT) != 0);
		wheelTrackingResponse = ((timerType & WHEEL_TRACKING_BIT) != 0);
		axisTrackingResponse = ((timerType & AXIS_TRACKING_BIT) != 0);
		if ((timerType & STOP_KEY_TIMER_BIT) != 0) {
			repeatUntilStopKey = true;
			stopKey = ExPar.StopKey.getInt();
		}
		responseEventGroup.set(deviceMask, directionMask, activeCodes);
		// get polled device state
		if (polledDeviceList != null) {
			for (Iterator it = polledDeviceList.iterator(); it.hasNext();) {
				PolledDevice pd = (PolledDevice) it.next();
				PolledDeviceData pdd = pd.read();
			}
		}
	}

	/**
	 * Set the active response timing flag. This method is called with a true
	 * argument by a TimingMonitor object immediately before its wait() method
	 * will be called. It is called with a false argument immediately after the
	 * TimingMonitor has been woken up by some thread calling its notify()
	 * method. If the activeResponseTiming flag is true then response events
	 * from the response devices are accepted and lead to a call to the
	 * TimingMonitor's setTimingEvent() method which actually leads to a
	 * notify() call.
	 * 
	 * @param s
	 *            if true then the response events are hot and if false no
	 *            response events are accepted.
	 */
	public void setActiveResponseTiming(boolean s) {
		activeResponseTiming = s;
		Debug.show(Debug.EVENTS, "ResponseManager.setActiveResponseTiming() "
				+ (activeResponseTiming ? "active" : "inactive"));
	}

	/**
	 * Clear all local variables and prepare the timing system for a new display
	 * list. Note that spurious response watching may not span across display
	 * lists. Thus the only thing which this method currently does is to clear
	 * the spurious response list. It is called by the presentation manger
	 * immediately before a display list presentation starts.
	 */
	public void clearTiming() {
		spuriousResponse.clear();
		watchSpuriousResponses = false;
	}

	// ----------------------------------------------------------
	// Adjustment implementation
	// ----------------------------------------------------------
	/**
	 * Enable adjustment responses for the currently active display.
	 * 
	 * @param adc
	 *            an adjustment control object which handles adjustment
	 *            responses.
	 */
	public void enableAdjustmentResponse(AdjustmentControl adc) {
		// System.out.println("RealTimeDisplayPanel.enableAdjustmentResponse()");
		adjustmentControl = adc;
		adjustmentResponse = true;
	}

	/** Disable adjustment responses for the currently active display. */
	public void disableAdjustmentResponse() {
		adjustmentResponse = false;
		adjustmentControl = null;
		// System.out.println("RealTimeDisplayPanel.disableAdjustmentResponse()");
	}

	/**
	 * Start the voice key for response timing. Called by the
	 * PresentationManager showAndWait() method if a voice key timer is
	 * required.
	 * 
	 * @param timeOut
	 *            maximum duration of voice key sound recording given in
	 *            nanoseconds.
	 */
	public void startVoiceKey(long timeOut) {
		AudioFormat format = new AudioFormat(44100, 16, 1, true, true);
		VoiceKeyRecorder vkr = new VoiceKeyRecorder(timeOut, 100.0,
				ExPar.VoiceKeyThreshold.getDouble(), null, format);
		vkr.setStopImmediately(ExPar.VoiceKeyStopImmediately.getFlag());
		vkr.setMediaEventListener(this);
		vkr.start();
	}

	// ----------------------------------------------------------
	// This is the ResponseController implementation
	// ----------------------------------------------------------
	/**
	 * Set the state for collecting responses during in-active response timer
	 * periods. If spurious response watching is set then response events which
	 * happen within time intervals where response timing is disabled are
	 * collected in a spurious response arrayand may be retrieved later.
	 * 
	 * @param state
	 *            if true then spurious responses are collected, if false they
	 *            are ignored.
	 */
	public void setWatchSpuriousResponses(boolean state) {
		watchSpuriousResponses = state;
		if (state) {
			watchSpuriousResponsesStartTime = HiresClock.getTimeNanos();
		}
	}

	/**
	 * Check whether spuriuos responses have been found since the last call of
	 * clearTiming().
	 * 
	 * @return true if there was a response in the inactive ResponseTimer state.
	 */
	public boolean hasSpuriousResponse() {
		return (!spuriousResponse.isEmpty());
	}

	/**
	 * Get the first spuriuos responses.
	 * 
	 * @return the first spurious response found or null if there was none since
	 *         the last clear() message.
	 */
	public ResponseEvent getFirstSpuriousResponse() {
		if (spuriousResponse.isEmpty())
			return (null);
		ResponseEvent e = (ResponseEvent) spuriousResponse.get(0);
		e.setTime(e.getTime() - watchSpuriousResponsesStartTime);
		return (e);
	}

	/**
	 * Get the most recent spuriuos response.
	 * 
	 * @return the latest spurious response found or null if there was none
	 *         since the last clear() message.
	 */
	public ResponseEvent getLastSpuriousResponse() {
		if (spuriousResponse.isEmpty())
			return (null);
		ResponseEvent e = (ResponseEvent) spuriousResponse.get(spuriousResponse
				.size() - 1);
		e.setTime(e.getTime() - watchSpuriousResponsesStartTime);
		return (e);
	}

	/**
	 * Get the list of spurious responses since the last clear() message.
	 * 
	 * @return the array of spurious responses found since the last clear()
	 *         message.
	 */
	public ArrayList getSpuriousResponse() {
		return (spuriousResponse);
	}

	private void addSpuriousResponse(ResponseEvent r) {
		// System.out.println("DisplayTimer.addSpuriousResponse(): " + r);
		spuriousResponse.add(r);
	}

	/**
	 * Register a polled device. The TimingMonitor will poll the device when the
	 * respective timer has the attribute XBUTTON_TIMER_BIT or the attribute
	 * AXIS_TRACKING_BIT set.
	 * 
	 * @param p
	 *            the polled device which should be registered for response
	 *            detection.
	 */
	public void addPolledDevice(PolledDevice p) {
		if (polledDeviceList == null) {
			polledDeviceList = new ArrayList(3);
		}
		polledDeviceList.add(p);
	}

	/**
	 * Remove a polled device.
	 * 
	 * @param p
	 *            the polled device which should be removed.
	 */
	public void removePolledDevice(PolledDevice p) {
		if (polledDeviceList != null) {
			polledDeviceList.remove(p);
		}
		if (polledDeviceList.size() == 0) {
			polledDeviceList = null;
		}
	}

	/**
	 * Checks whether polled devices have been registered.
	 * 
	 * @return true if polled devices have been registered and false if not.
	 */
	public boolean pollingIsRequired() {
		return polledDeviceList != null;
	}

	/**
	 * Add a SpaceMouse device as an external device for response detection.
	 * SpaceMouse axes are tracked when the respective timer has the
	 * AXIS_TRACKING_BIT set. SpaceMouse buttons are active if the
	 * XBUTTON_TIMER_BIT is set.
	 * 
	 * @param p
	 *            the SpaceMouse device to be added.
	 */
	public void addSpaceMouse(SpaceMouse p) {
		spaceMouse = p;
	}

	/**
	 * Remove the given SpaceMouse for response detection.
	 * 
	 * @param p
	 *            the SpaceMouse device to be removed.
	 */
	public void removeSpaceMouse(SpaceMouse p) {
		spaceMouse = null;
	}

	// ----------------------------------------------------------
	// This is the KeyboardResponseListener implementation
	// ----------------------------------------------------------
	/**
	 * The subject has pressed a keyboard key. This method is called by the
	 * presentation manager's keyboard response dispatcher.
	 */
	public void keyPressed(KeyEvent e) {
		long tm = HiresClock.getTimeNanos();
		ResponseEvent r = new ResponseEvent(e, DOWN_TIMER_BIT);
		int rCode = r.getCode();
		Debug.show(Debug.EVENTS, "ResponseManager.keyPressed(): Event code = "
				+ rCode);
		if (activeResponseTiming) {
			Debug.show(Debug.EVENTS,
					"ResponseManager.keyPressed(): Timing is active.");
			if (adjustmentResponse) {
				Debug.show(Debug.EVENTS,
						"ResponseManager.keyPressed(): Do adjustment.");
				adjustmentControl.adjust(rCode);
			}
			int responseCode = responseEventGroup.getCode(r);
			if (responseCode >= 0) {
				Debug.show(Debug.EVENTS,
						"ResponseManager.keyPressed(): Response code = "
								+ responseCode);
				if (repeatUntilStopKey) {
					Debug.show(Debug.EVENTS,
							"ResponseManager.keyPressed(): Repeat until stop key ("
									+ stopKey + ") found.");
					if (rCode == stopKey) {
						Debug.show(Debug.EVENTS,
								"ResponseManager.keyPressed(): Stop key found.");
						if (activeDisplay.getAllowTimerStop(responseCode)) {
							Debug.show(Debug.EVENTS,
									"ResponseManager.keyPressed(): Stop timing interval.");
							timingMonitor.setTimingEvent(tm, KEY_TIMER_BIT,
									responseCode, e.getKeyChar(),
									e.getKeyLocation());
						} else {
							Debug.show(Debug.EVENTS,
									"ResponseManager.keyPressed(): Timer stopping not allowed.");
						}
					} else {
						Debug.show(Debug.EVENTS,
								"ResponseManager.keyPressed(): Call display.setKeyResponse()");
						if (activeDisplay.setKeyResponse(e)) {
							activeDisplay.showCurrentTimingGroup();
							activeDisplay.clearNextTimingGroupImagePreload();
						}
					}
				} else {
					if (activeDisplay.getAllowTimerStop(responseCode)) {
						Debug.show(Debug.EVENTS,
								"ResponseManager.keyPressed(): Stop timing interval.");
						timingMonitor.setTimingEvent(tm, KEY_TIMER_BIT,
								responseCode, e.getKeyChar(),
								e.getKeyLocation());
					} else {
						Debug.show(Debug.EVENTS,
								"ResponseManager.keyPressed(): Timer stopping not allowed.");
					}
				}
			} else {
				Debug.show(Debug.EVENTS,
						"ResponseManager.keyPressed(): Response not valid");
			}
			e.consume();
		} else {
			Debug.show(
					Debug.EVENTS,
					"ResponseManager.keyPressed(): Timing is not active. Add spurious response event.");
			timingMonitor.setSpuriousResponseEvent(tm, KEY_TIMER_BIT, rCode);
			addSpuriousResponse(r);
		}
	}

	/**
	 * The subject has released a keyboard key. This method is called by the
	 * presentation manager's keyboard response dispatcher.
	 */
	public void keyReleased(KeyEvent e) {
		long tm = HiresClock.getTimeNanos();
		ResponseEvent r = new ResponseEvent(e, UP_TIMER_BIT);
		int rCode = r.getCode();
		Debug.show(Debug.EVENTS, "ResponseManager.keyReleased(): Event code = "
				+ rCode);
		if (activeResponseTiming) {
			Debug.show(Debug.EVENTS,
					"ResponseManager.keyReleased(): Timing is active.");
			int responseCode = responseEventGroup.getCode(r);
			if (responseCode >= 0) {
				Debug.show(Debug.EVENTS,
						"ResponseManager.keyReleased(): Response code = "
								+ responseCode);
				if (activeDisplay.getAllowTimerStop(responseCode)) {
					Debug.show(Debug.EVENTS,
							"ResponseManager.keyReleased(): Stop timing interval.");
					timingMonitor.setTimingEvent(tm, KEY_TIMER_BIT,
							responseCode, e.getKeyChar(), e.getKeyLocation());
				} else {
					Debug.show(Debug.EVENTS,
							"ResponseManager.keyReleased(): Timer stopping not allowed.");
				}
			} else {
				Debug.show(Debug.EVENTS,
						"ResponseManager.keyReleased(): Response not valid.");
			}
			e.consume();
		} else {
			Debug.show(
					Debug.EVENTS,
					"ResponseManager.keyReleased(): Timing is not active. Add spurious response event.");
			timingMonitor.setSpuriousResponseEvent(tm, KEY_TIMER_BIT, rCode);
			addSpuriousResponse(r);
		}
	}

	// ----------------------------------------------------------
	// This is the mouse listener implementation
	// ----------------------------------------------------------
	/**
	 * Invoked when the mouse has been clicked. This means that a button has
	 * been pressed and released.
	 */
	public void mouseClicked(MouseEvent e) {
	}

	/** Invoked when the mouse enters a component. */
	public void mouseEntered(MouseEvent e) {
	}

	/** Invoked when the mouse exits a component. */
	public void mouseExited(MouseEvent e) {
	}

	/** Invoked when a mouse button has been pressed. */
	public void mousePressed(MouseEvent e) {
		long tm = HiresClock.getTimeNanos();
		// System.out.println("ResponseManager.mousePressed() State=" +
		// (activeResponseTiming? "active": "inactive"));
		ResponseEvent r = new ResponseEvent(e, DOWN_TIMER_BIT);
		if (activeResponseTiming) {
			Debug.show(Debug.EVENTS, "ResponseManager.mousePressed(): Active");
			if (mouseTrackingResponse) {
				Debug.show(Debug.EVENTS, "ResponseManager.mousePressed() at "
						+ tm + " [ns] relative to " + responseIntervalStart
						+ " [ns]");
				if (activeDisplay.setPointerActivationState(r, tm
						- responseIntervalStart)) {
					Debug.show(Debug.EVENTS,
							"ResponseManager.mousePressed() re-show current timing group.");
					activeDisplay.showCurrentTimingGroup();
					activeDisplay.clearNextTimingGroupImagePreload();
				}
			}
			int responseCode = responseEventGroup.getCode(r);
			if (responseCode >= 0) {
				if (activeDisplay.getAllowTimerStop(responseCode)) {
					Debug.show(Debug.EVENTS,
							"ResponseManager.mousePressed(): Timer stop allowed, Valid response");
					timingMonitor.setTimingEvent(tm, MOUSE_BUTTON_TIMER_BIT,
							responseCode, e.getPoint());
				}
			} else {
				Debug.show(Debug.EVENTS,
						"ResponseManager.mousePressed(): Response not valid");
			}
			e.consume();
		} else {
			Debug.show(Debug.EVENTS,
					"ResponseManager.mousePressed(): Not active");
			timingMonitor.setSpuriousResponseEvent(tm, MOUSE_BUTTON_TIMER_BIT,
					r.getCode(), e.getPoint());
			addSpuriousResponse(r);
		}
	}

	/** Invoked when a mouse button has been released. */
	public void mouseReleased(MouseEvent e) {
		long tm = HiresClock.getTimeNanos();
		// System.out.println("ResponseManager.mouseReleased() State=" +
		// (activeResponseTiming? "active": "inactive"));
		ResponseEvent r = new ResponseEvent(e, UP_TIMER_BIT);
		if (activeResponseTiming) {
			Debug.show(Debug.EVENTS, "ResponseManager.mouseReleased(): Active");
			if (mouseTrackingResponse) {
				Debug.show(Debug.EVENTS, "ResponseManager.mouseReleased() at "
						+ tm + " [ns] relative to " + responseIntervalStart
						+ " [ns]");
				if (activeDisplay.setPointerReleaseState(r, tm
						- responseIntervalStart)) {
					Debug.show(Debug.EVENTS,
							"ResponseManager.mouseReleased(): re-show current timing group");
					activeDisplay.showCurrentTimingGroup();
					activeDisplay.clearNextTimingGroupImagePreload();
				}
			}
			int responseCode = responseEventGroup.getCode(r);
			if (responseCode >= 0) {
				if (activeDisplay.getAllowTimerStop(responseCode)) {
					Debug.show(Debug.EVENTS,
							"ResponseManager.mouseReleased(): Valid response");
					timingMonitor.setTimingEvent(tm, MOUSE_BUTTON_TIMER_BIT,
							responseCode, e.getPoint());
				}
			} else {
				Debug.show(Debug.EVENTS,
						"ResponseManager.mouseReleased(): Response not valid");
			}
			e.consume();
		} else {
			Debug.show(Debug.EVENTS,
					"ResponseManager.mouseReleased(): Not active");
			timingMonitor.setSpuriousResponseEvent(tm, MOUSE_BUTTON_TIMER_BIT,
					r.getCode(), e.getPoint());
			addSpuriousResponse(r);
		}
	}

	// ----------------------------------------------------------
	// This is the mouse motion listener implementation
	// ----------------------------------------------------------
	/** Invoked when the mouse has been moved with a button down. */
	public void mouseDragged(MouseEvent e) {
		if (activeResponseTiming && mouseTrackingResponse) {
			Debug.show(Debug.EVENTS,
					"ResponseManager.mouseDragged(): Tracking active");
			ResponseEvent r = new ResponseEvent(e, 0);
			if (activeDisplay.setPointerDraggedState(r)) {
				activeDisplay.showCurrentTimingGroup();
				activeDisplay.clearNextTimingGroupImagePreload();
			}
		}
	}

	/** Invoked when the mouse has been moved with no button down. */
	public void mouseMoved(MouseEvent e) {
		if (activeResponseTiming && mouseTrackingResponse) {
			Debug.show(Debug.EVENTS,
					"ResponseManager.mouseMoved(): Tracking active");
			ResponseEvent r = new ResponseEvent(e, 0);
			if (activeDisplay.setPointerMovedState(r)) {
				activeDisplay.showCurrentTimingGroup();
				activeDisplay.clearNextTimingGroupImagePreload();
			}
		}
	}

	// ----------------------------------------------------------
	// This is the mouse wheel listener implementation
	// ----------------------------------------------------------
	public void mouseWheelMoved(MouseWheelEvent e) {
		if (activeResponseTiming && wheelTrackingResponse) {
			Debug.show(
					Debug.EVENTS,
					"ResponseManager.mouseWheelMoved(): "
							+ e.getWheelRotation());
			double[] d = new double[1];
			d[0] = e.getWheelRotation();
			if (activeDisplay.setAxisDeltas(d)) {
				activeDisplay.showCurrentTimingGroup();
				activeDisplay.clearNextTimingGroupImagePreload();
			}
		}
	}

	// ----------------------------------------------------------
	// This is the SpaceMouseListener implementation
	// ----------------------------------------------------------
	/** A SpaceMouse button has changed its state. */
	public void spaceMouseButton(SpaceMouseEvent e) {
		long tm = HiresClock.getTimeNanos();
		ResponseEvent r = new ResponseEvent(e,
				e.isButtonPressed() ? DOWN_TIMER_BIT : UP_TIMER_BIT);
		int rCode = r.getCode();
		if (activeResponseTiming) {
			Debug.show(Debug.EVENTS,
					"ResponseManager.spaceMouseButton(): Active [button = "
							+ rCode + "]");
			int responseCode = responseEventGroup.getCode(r);
			if (responseCode >= 0) {
				if (activeDisplay.getAllowTimerStop(responseCode)) {
					Debug.show(Debug.EVENTS,
							"ResponseManager.spaceMouseButton(): Valid response");
					timingMonitor.setTimingEvent(tm, XBUTTON_TIMER_BIT,
							responseCode);
				}
			} else {
				Debug.show(Debug.EVENTS,
						"ResponseManager.spaceMouseButton(): Response not valid");
			}
		} else {
			Debug.show(Debug.EVENTS,
					"ResponseManager.spaceMouseButton(): not active [key = "
							+ rCode + "]");
			timingMonitor.setSpuriousResponseEvent(tm, XBUTTON_TIMER_BIT,
					r.getCode());
			addSpuriousResponse(r);
		}
	}

	/** A SpaceMouse axis has changed its state. */
	public void spaceMouseAxis(SpaceMouseEvent e) {
		if (activeResponseTiming && axisTrackingResponse) {
			Debug.show(
					Debug.EVENTS,
					"ResponseManager.spaceMouseAxisChanged(): "
							+ StringExt.valueOf(e.getAxisDeltas()));
			if (activeDisplay.setAxisDeltas(e.getAxisDeltas())) {
				activeDisplay.showCurrentTimingGroup();
				activeDisplay.clearNextTimingGroupImagePreload();
			}
		}
	}

	/** The SpaceMouse has generated the Zero event. */
	public void spaceMouseZero(SpaceMouseEvent e) {
	}

	// ----------------------------------------------------------
	// This is the external button listener implementation
	// ----------------------------------------------------------
	/** Invoked when an external response box button has been pressed. */
	public void externalButtonPressed(ExternalButtonEvent e) {
		long tm = HiresClock.getTimeNanos();
		// System.out.println("ResponseManager.externalButtonPressed() State=" +
		// (activeResponseTiming? "active": "inactive"));
		ResponseEvent r = new ResponseEvent(e, DOWN_TIMER_BIT);
		int rCode = r.getCode();
		if (activeResponseTiming) {
			Debug.show(Debug.EVENTS,
					"ResponseManager.externalButtonPressed(): Active [key = "
							+ rCode + "]");
			int responseCode = responseEventGroup.getCode(r);
			if (responseCode >= 0) {
				if (activeDisplay.getAllowTimerStop(responseCode)) {
					Debug.show(Debug.EVENTS,
							"ResponseManager.externalButtonPressed(): Valid response");
					timingMonitor.setTimingEvent(tm, XBUTTON_TIMER_BIT,
							responseCode);
				}
			} else {
				Debug.show(Debug.EVENTS,
						"ResponseManager.externalButtonPressed(): Response not valid");
			}
		} else {
			Debug.show(Debug.EVENTS,
					"ResponseManager.externalButtonPressed(): not active [key = "
							+ rCode + "]");
			timingMonitor.setSpuriousResponseEvent(tm, XBUTTON_TIMER_BIT,
					r.getCode());
			addSpuriousResponse(r);
		}
	}

	/** Invoked when an external response box button has been released. */
	public void externalButtonReleased(ExternalButtonEvent e) {
		long tm = HiresClock.getTimeNanos();
		// System.out.println("ResponseManager.externalButtonReleased() State="
		// + (activeResponseTiming? "active": "inactive"));
		ResponseEvent r = new ResponseEvent(e, UP_TIMER_BIT);
		int rCode = r.getCode();
		if (activeResponseTiming) {
			Debug.show(Debug.EVENTS,
					"ResponseManager.externalButtonReleased(): Active [key = "
							+ rCode + "]");
			int responseCode = responseEventGroup.getCode(r);
			if (responseCode >= 0) {
				if (activeDisplay.getAllowTimerStop(responseCode)) {
					Debug.show(Debug.EVENTS,
							"ResponseManager.externalButtonReleased(): Valid response");
					timingMonitor.setTimingEvent(tm, XBUTTON_TIMER_BIT,
							responseCode);
				}
			} else {
				Debug.show(Debug.EVENTS,
						"ResponseManager.externalButtonReleased(): Response not valid");
			}
		} else {
			Debug.show(Debug.EVENTS,
					"ResponseManager.externalButtonReleased(): Not active [key = "
							+ rCode + "]");
			timingMonitor.setSpuriousResponseEvent(tm, XBUTTON_TIMER_BIT,
					r.getCode());
			addSpuriousResponse(r);
		}
	}

	// ----------------------------------------------------------
	// This is the serial line input listener implementation
	// ----------------------------------------------------------
	/** Invoked when a serial line signals input of a single line of text. */
	public void serialLineInput(SerialLineInputEvent e) {
		long tm = HiresClock.getTimeNanos();
		// System.out.println("ResponseManager.serialLineInput() State=" +
		// (activeResponseTiming? "active": "inactive"));
		if (activeResponseTiming) {
			if (activeDisplay.getAllowTimerStop(0)) {
				Debug.show(Debug.EVENTS,
						"ResponseManager.serialLineInput(): Active");
				timingMonitor.setTimingEvent(tm, SERIAL_LINE_TIMER_BIT,
						e.getText());
			}
		} else {
			Debug.show(Debug.EVENTS,
					"ResponseManager.serialLineInput(): Not active");
		}
	}

	// ----------------------------------------------------------
	// This is the MediaEventListener implementation
	// ----------------------------------------------------------
	/** Invoked when a media processor has performed an action. */
	public void mediaActionPerformed(MediaEvent e) {
		int id = e.getID();
		Debug.show(Debug.EVENTS,
				"ResponseManager.mediaActionPerformed(): ID = " + id);
		if (activeDisplay != null) {
			ResponseEvent r = new ResponseEvent(e);
			Debug.show(Debug.EVENTS, "Detected: " + r.toString());
			int responseCode = responseEventGroup.getCode(r);
			if (responseCode >= 0) {
				if (activeDisplay.getAllowTimerStop(responseCode)) {
					Debug.show(Debug.EVENTS,
							"ResponseManager.mediaActionPerformed(): Valid code");
					timingMonitor.setTimingEvent(e.getWhen(), r.getDevice(),
							responseCode);
				}
			} else {
				Debug.show(
						Debug.EVENTS,
						"ResponseManager.mediaActionPerformed(): Invalid code. [id="
								+ id
								+ /* ", direction=" + direction + */", responseCode="
								+ responseCode + "]");
			}
		} else {
			Debug.show(Debug.EVENTS,
					"ResponseManager.mediaActionPerformed(): No active display");
		}
	}

	// ----------------------------------------------------------
	// This implements polled response devices
	// ----------------------------------------------------------
	/**
	 * Read a polled device and decide what to do. This method is only called if
	 * the XBUTTON_TIMER_BIT or the AXIS_TIMER_BIT of a timer is set and the
	 * polledDeviceList is nonempty. The call originates from the WaitLock
	 * object used by the TimingMonitor class. This means that it will only be
	 * called when response timing is active.
	 */
	public void readPolledDevice() {
		if (pollingIsRequired()) {
			for (Iterator it = polledDeviceList.iterator(); it.hasNext();) {
				PolledDevice pd = (PolledDevice) it.next();
				PolledDeviceData pdd = pd.read();
				if (pdd.getChangedButtonIndex() >= 0) {
					ResponseEvent r = new ResponseEvent(pdd);
					int rCode = r.getCode();
					Debug.show(Debug.EVENTS,
							"ResponseManager.readPolledDevice(): [button = "
									+ rCode + "]");
					int responseCode = responseEventGroup.getCode(r);
					if (responseCode >= 0) {
						if (activeDisplay.getAllowTimerStop(responseCode)) {
							Debug.show(Debug.EVENTS,
									"ResponseManager.readPolledDevice(): Valid response");
							timingMonitor.setTimingEvent(pdd.getWhen(),
									XBUTTON_TIMER_BIT, responseCode);
						}
					} else {
						Debug.show(Debug.EVENTS,
								"ResponseManager.readPolledDevice(): Response not valid");
					}
				} else if (pdd.getChangedDirectionalIndex() >= 0) {
					ResponseEvent r = new ResponseEvent(pdd);
					int rCode = r.getCode();
					Debug.show(Debug.EVENTS,
							"ResponseManager.readPolledDevice(): [direction = "
									+ rCode + "]");
					int responseCode = responseEventGroup.getCode(r);
					if (responseCode >= 0) {
						if (activeDisplay.getAllowTimerStop(responseCode)) {
							Debug.show(Debug.EVENTS,
									"ResponseManager.readPolledDevice(): Valid response");
							timingMonitor.setTimingEvent(pdd.getWhen(),
									XBUTTON_TIMER_BIT, responseCode);
						}
					} else {
						Debug.show(Debug.EVENTS,
								"ResponseManager.readPolledDevice(): Response not valid");
					}
				} else {
					if (axisTrackingResponse) {
						if (activeDisplay.setAxisDeltas(pdd.getAxisDeltas())) {
							activeDisplay.showCurrentTimingGroup();
							activeDisplay.clearNextTimingGroupImagePreload();
						}
					}
				}
			}
		}
	}
}
