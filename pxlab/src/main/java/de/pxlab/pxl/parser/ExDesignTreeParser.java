/* Generated By:JavaCC: Do not edit this line. ExDesignTreeParser.java */
package de.pxlab.pxl.parser;

import java.util.*;
import java.io.*;
import de.pxlab.util.StringExt;
import de.pxlab.pxl.*;

/**
 * @author H. Irtel
 * @version 0.11.0
 * @see de.pxlab.pxl.ExDesignNode
 */
/*
 * 
 * To Do:
 * 
 * make sure that the parser only sees ASCII input!
 * 
 * NOTE: LOOKAHEAD(n) means look at the next n input tokens and then take the
 * first of a series of choices which fit these n tokens.
 * 
 * // String name = new String( sourceFile.readLine().getBytes(), "ISO-8859-1");
 * 
 * 
 * 02/27/01 introduced Context() and Procedure() nodes 03/05/01 introduced
 * ParameterGroup() nodes 03/08/01 changed mofifier assignments
 * 
 * 03/16/01 wrote documentation - no more undocumented changes !!! 03/21/01
 * added text line parsers for the design tree editor 04/01/01 new: public
 * production ExParValue runtimeParameterValue() private production ExParValue
 * literalArray() private production String signedLiteral() 05/29/01 allow empty
 * blocks for Session() and Block()
 * 
 * 09/26/01 moved Session/Block/Trial arguments declaration into the Context()
 * block and simplified Context() block names
 * 
 * 11/03/01 moved grammar to JavaCC
 * 
 * 01/16/02 allow Context(), Factors(), and AssignmentGroup() declarations
 * without a block
 * 
 * 02/19/02 removed ':adjustable' modification of Display class name. This is
 * done at run time.
 * 
 * 06/20/02 allow multiple procedure unit nodes.
 * 
 * 08/15/02 major revision for easier editing of designs with multiple procedure
 * units
 * 
 * 11/05/02 fixed null pointer bug int parValuesDefinition().
 * 
 * 2004/09/15 removed OCTAL_LITERAL since it prevented the use of decimal
 * integers with leading zeros.
 * 
 * 2004/12/22 completely rewrote the grammer definition in order to make it more
 * clear and easier to understand. The expression() definition is completely new
 * and almost identical to Java's expression grammar now.
 * 
 * 2005/01/04 Store preceding comments in ExDesignNodes
 * 
 * 2005/01/10 added BRACKET_OP to better handle brackets
 * 
 * 2005/02/18 the Procedure() now is a DisplayList in the same way as Session()
 * is.
 * 
 * 2005/09/12 allow short class constant names from packages de.pxlab, java, and
 * javax
 */
public class ExDesignTreeParser implements ExDesignTreeParserConstants {
	/** Import node type for Display nodes. */
	private static final int DISPLAY_NODE = 1;
	/** Import node type for DisplayList nodes. */
	private static final int CONTEXT_SUB_NODE = 2;
	/** Import node type for Session nodes. */
	private static final int SESSION_NODE = 3;
	/** Import node type for Block nodes. */
	private static final int BLOCK_NODE = 4;
	/** Import node type for Block nodes. */
	private static final int TRIAL_NODE = 5;
	/**
	 * Stores the arrays of display list parameter names. These names are
	 * collected during display list definitions and are retrieved later for
	 * executing display list calls.
	 */
	private HashMap displayListParNames = new HashMap(10);

	/**
	 * Enter a descriptor of display list parameter names into the table of
	 * display list parameter names.
	 * 
	 * @param n
	 *            the name of the display list.
	 * @param a
	 *            the descriptor of parameter names.
	 */
	private void enterDisplayListParNames(String n, String[] a) {
		Debug.show(Debug.PARSER, n + " parameters: " + a);
		if (a != null) {
			displayListParNames.put(n, a);
		}
	}

	/**
	 * Enter all display list parameter name arrays of the given map into this
	 * parser's map of parameter name arrays.
	 */
	private void enterDisplayListParNames(HashMap m) {
		displayListParNames.putAll(m);
	}

	/**
	 * Retrieve a descriptor of display list parameter names from the table of
	 * display list parameter names.
	 * 
	 * @param n
	 *            the name of the display list.
	 * @return the descriptor of names contained in the argument list.
	 */
	private String[] getDisplayListParNames(String n) {
		return (String[]) displayListParNames.get(n);
	}

	/**
	 * Retrieve a preceding comment from a token object. The comments preceding
	 * a token are stored in the specialToken field of a Token object.
	 */
	private String getPrecedingComments(Token t) {
		if (t.specialToken == null)
			return null;
		Token tmp_t = t.specialToken;
		while (tmp_t.specialToken != null)
			tmp_t = tmp_t.specialToken;
		StringBuffer sb = new StringBuffer();
		while (tmp_t != null) {
			sb.append(/* "\n" + */tmp_t.image);
			tmp_t = tmp_t.next;
		}
		return sb.toString();
	}

	/** Send a semantic error note to the console. */
	private void semanticError(Token t, String s) {
		Syslog.out.println("Error in line " + t.beginLine + " column "
				+ t.beginColumn + ": " + s);
	}

	/**
	 * Main entry point for parsing an experimental design file. The input
	 * stream of the parser must deliver a valid experimental design.
	 * 
	 * <p>
	 * An experiment starts with the keyword 'Experiment' followed by an
	 * argument list and a block which contains three subnodes: context,
	 * factors, and procedure declarations.
	 * 
	 * @throws ParseException
	 *             if there is a syntax error.
	 * @return the ExDesignNode object of the experiment declaration.
	 * @see de.pxlab.pxl.ExDesign
	 * @see de.pxlab.pxl.ExDesignNode
	 */
	final public ExDesignNode experimentDeclaration() throws ParseException {
		Token t;
		ExDesignNode experiment = null;
		ExDesignNode factors = null;
		ExDesignNode context = null;
		ExDesignNode procedure = null;
		String[] parNames = null;
		Debug.show(Debug.PARSER,
				"\nStarting parser with experimentDeclaration()");
		t = jj_consume_token(EXPERIMENT);
		experiment = new ExDesignNode(ExDesignNode.ExperimentNode, 3);
		experiment.setTokenPosition(t.beginLine, t.beginColumn);
		if (t.specialToken != null)
			experiment.setComment(getPrecedingComments(t));
		parNames = parameterIdentifierList();
		enterDisplayListParNames("Experiment", parNames);
		experiment.setParNames(parNames);
		if (parNames != null) {
			ExParValue[] values = new ExParValue[parNames.length];
			for (int i = 0; i < parNames.length; i++) {
				values[i] = new ExParValueUndefined();
			}
			experiment.setParValues(values);
		}
		Debug.show(Debug.PARSER, "Starting node " + experiment);
		jj_consume_token(52);
		context = contextDeclaration();
		experiment.add(context);
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case FACTORS:
			factors = factorsDeclaration();
			experiment.add(factors);
			break;
		default:
			jj_la1[0] = jj_gen;
			;
		}
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case PROCEDURE:
			procedure = procedureDeclaration();
			experiment.add(procedure);
			break;
		default:
			jj_la1[1] = jj_gen;
			;
		}
		jj_consume_token(53);
		jj_consume_token(0);
		Debug.show(Debug.PARSER, "Finished node " + experiment);
		{
			if (true)
				return (experiment);
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Defines the global parameter context and all experimental stimuli. An
	 * experimental context starts with the keyword 'Context' followed by a list
	 * of runtime arguments and a block which contains global assignment groups
	 * and display list definition subnodes.
	 * 
	 * @throws ParseException
	 *             if there is a syntax error.
	 * @return the node of the context declaration.
	 */
	final public ExDesignNode contextDeclaration() throws ParseException {
		Token t;
		ExDesignNode context = null;
		ExDesignNode a = null;
		String[] parNames = null;
		ArrayList aList = null;
		t = jj_consume_token(CONTEXT);
		context = new ExDesignNode(ExDesignNode.ContextNode, 10);
		context.setTokenPosition(t.beginLine, t.beginColumn);
		if (t.specialToken != null)
			context.setComment(getPrecedingComments(t));
		Debug.show(Debug.PARSER, "Begin node: " + context);
		parNames = parameterIdentifierList();
		context.setParNames(parNames);
		Debug.show(Debug.PARSER, "Starting node " + context);
		jj_consume_token(52);
		label_1: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case EXPERIMENTDATA:
			case PROCEDURE:
			case PROCEDUREEND:
			case PROCEDUREDATA:
			case SESSION:
			case SESSIONEND:
			case SESSIONDATA:
			case BLOCK:
			case BLOCKEND:
			case BLOCKDATA:
			case TRIAL:
			case TRIALDATA:
			case ASSIGNMENTGROUP:
			case IMPORT:
				;
				break;
			default:
				jj_la1[2] = jj_gen;
				break label_1;
			}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case EXPERIMENTDATA:
			case PROCEDURE:
			case PROCEDUREEND:
			case PROCEDUREDATA:
			case SESSION:
			case SESSIONEND:
			case SESSIONDATA:
			case BLOCK:
			case BLOCKEND:
			case BLOCKDATA:
			case TRIAL:
			case TRIALDATA:
			case ASSIGNMENTGROUP:
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case EXPERIMENTDATA:
				case PROCEDURE:
				case PROCEDUREEND:
				case PROCEDUREDATA:
				case SESSION:
				case SESSIONEND:
				case SESSIONDATA:
				case BLOCK:
				case BLOCKEND:
				case BLOCKDATA:
				case TRIAL:
				case TRIALDATA:
					a = displayListDeclaration();
					break;
				case ASSIGNMENTGROUP:
					a = assignmentGroupDeclaration();
					break;
				default:
					jj_la1[3] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
				context.add(a);
				break;
			case IMPORT:
				aList = importedExDesignNodeDeclarationList(CONTEXT_SUB_NODE);
				for (int i = 0; i < aList.size(); i++)
					context.add((ExDesignNode) aList.get(i));
				break;
			default:
				jj_la1[4] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
		}
		jj_consume_token(53);
		Debug.show(Debug.PARSER, "Finished node " + context);
		{
			if (true)
				return context;
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * A display list declaration.
	 * 
	 * <p>
	 * The declaration starts with a display list identifier followed by a list
	 * of runtime parameter names. The block of the display list declaration
	 * contains the sequence of displays contained in this display list.
	 * <p>
	 * The declaration may contain an instance modifier appended to the display
	 * list type name. The instance name becomes the display list name.
	 * 
	 * @throws ParseException
	 *             if there is a syntax error.
	 * @return the node of the display list declaration.
	 */
	final public ExDesignNode displayListDeclaration() throws ParseException {
		DisplayListIdentifier t = null;
		String nd = null;
		int type = 0;
		ExDesignNode dList = null;
		ExDesignNode dsp = null;
		String[] parNames = null;
		ArrayList dspList = null;
		t = displayListIdentifier();
		nd = t.toString();
		int id = t.getNodeType(true);
		if (id >= 0) {
			type = id;
		} else {
			{
				if (true)
					throw new ParseException();
			}
		}
		dList = new ExDesignNode(type, 1);
		dList.setName(nd);
		dList.setTokenPosition(t.beginLine, t.beginColumn);
		dList.setComment(t.getComment());
		Debug.show(Debug.PARSER, "Begin node: " + dList);
		parNames = displayListParameterIdentifierList(nd);
		enterDisplayListParNames(nd, parNames);
		dList.setParNames(parNames);
		Debug.show(Debug.PARSER, "Starting node " + dList);
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case 52:
			jj_consume_token(52);
			label_2: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case IMPORT:
				case IDENTIFIER:
					;
					break;
				default:
					jj_la1[5] = jj_gen;
					break label_2;
				}
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case IDENTIFIER:
					dsp = displayDeclaration();
					if (dsp != null) {
						if (dList.isDataDisplayList()) {
							dsp.setType(ExDesignNode.DataDisplayNode);
						}
						dList.add(dsp);
					}
					break;
				case IMPORT:
					dspList = importedExDesignNodeDeclarationList(DISPLAY_NODE);
					if (dspList.size() > 0) {
						for (int i = 0; i < dspList.size(); i++) {
							dsp = (ExDesignNode) dspList.get(i);
							if (dList.isDataDisplayList()) {
								dsp.setType(ExDesignNode.DataDisplayNode);
							}
							dList.add(dsp);
						}
					}
					break;
				default:
					jj_la1[6] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			}
			jj_consume_token(53);
			break;
		case 54:
			jj_consume_token(54);
			break;
		default:
			jj_la1[7] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}
		Debug.show(Debug.PARSER, "Finished node " + dList);
		{
			if (true)
				return (dList);
		}
		throw new Error("Missing return statement in function");
	}

	final public ArrayList importedExDesignNodeDeclarationList(int type)
			throws ParseException {
		Token dt;
		Token ft;
		ArrayList nodeList = new ArrayList(10);
		jj_consume_token(IMPORT);
		jj_consume_token(55);
		dt = jj_consume_token(STRING_LITERAL);
		jj_consume_token(56);
		ft = jj_consume_token(STRING_LITERAL);
		jj_consume_token(57);
		jj_consume_token(54);
		String dir = StringExt.unquoteHTML(dt.toString());
		String fn = StringExt.unquoteHTML(ft.toString());
		String fs = FileBase.loadString(dir, fn);
		if (StringExt.nonEmpty(fs)) {
			byte[] buf = fs.getBytes();
			InputStream ins = new ByteArrayInputStream(buf);
			ExDesignTreeParser pp = new ExDesignTreeParser(ins,
					Base.getEncoding());
			Debug.show(Debug.FILES,
					"ExDesignTreeParser.importedDisplayDeclaration(): Read design file "
							+ fn);
			Debug.show(Debug.PARSER,
					"ExDesignTreeParser.importedDisplayDeclaration(): Parse file "
							+ fn + " ...");
			try {
				if (type == DISPLAY_NODE) {
					nodeList = pp.importedDisplayDeclarationList();
				} else if (type == CONTEXT_SUB_NODE) {
					nodeList = pp.importedContextSubnodeDeclarationList();
					enterDisplayListParNames(pp.displayListParNames);
				} else if (type == TRIAL_NODE) {
					pp.enterDisplayListParNames(displayListParNames);
					nodeList = pp.importedTrialList();
				} else if (type == BLOCK_NODE) {
					pp.enterDisplayListParNames(displayListParNames);
					nodeList = pp.importedBlockList();
				} else if (type == SESSION_NODE) {
					pp.enterDisplayListParNames(displayListParNames);
					nodeList = pp.importedSessionList();
				}
			} catch (ParseException pex) {
				new SyntaxError(StringExt.fixedParserErrorMessage(pex, fn));
				// throw new IOException("Syntax error in file " + fn);
			} catch (TokenMgrError tme) {
				new SyntaxError(StringExt.fixedParserErrorMessage(tme, fn));
				// throw new IOException("Token error in file " + fn);
			}
		} else {
			new FileError("Import file " + FileBase.createResourcePath(dir, fn)
					+ " is missing.");
		}
		{
			if (true)
				return nodeList;
		}
		throw new Error("Missing return statement in function");
	}

	/** An imported list of Display declarations. */
	final public ArrayList importedDisplayDeclarationList()
			throws ParseException {
		ArrayList nodeList = new ArrayList(10);
		ExDesignNode node = null;
		label_3: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case IDENTIFIER:
				;
				break;
			default:
				jj_la1[8] = jj_gen;
				break label_3;
			}
			node = displayDeclaration();
			nodeList.add(node);
		}
		{
			if (true)
				return nodeList;
		}
		throw new Error("Missing return statement in function");
	}

	/** An imported list of DisplayList or AssignmentGroup declarations. */
	final public ArrayList importedContextSubnodeDeclarationList()
			throws ParseException {
		ArrayList nodeList = new ArrayList(10);
		ExDesignNode node = null;
		label_4: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case EXPERIMENTDATA:
			case PROCEDURE:
			case PROCEDUREEND:
			case PROCEDUREDATA:
			case SESSION:
			case SESSIONEND:
			case SESSIONDATA:
			case BLOCK:
			case BLOCKEND:
			case BLOCKDATA:
			case TRIAL:
			case TRIALDATA:
			case ASSIGNMENTGROUP:
				;
				break;
			default:
				jj_la1[9] = jj_gen;
				break label_4;
			}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case EXPERIMENTDATA:
			case PROCEDURE:
			case PROCEDUREEND:
			case PROCEDUREDATA:
			case SESSION:
			case SESSIONEND:
			case SESSIONDATA:
			case BLOCK:
			case BLOCKEND:
			case BLOCKDATA:
			case TRIAL:
			case TRIALDATA:
				node = displayListDeclaration();
				break;
			case ASSIGNMENTGROUP:
				node = assignmentGroupDeclaration();
				break;
			default:
				jj_la1[10] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			nodeList.add(node);
		}
		{
			if (true)
				return nodeList;
		}
		throw new Error("Missing return statement in function");
	}

	/** An imported list of Session declarations. */
	final public ArrayList importedSessionList() throws ParseException {
		ArrayList nodeList = new ArrayList(10);
		ExDesignNode node = null;
		label_5: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case SESSION:
				;
				break;
			default:
				jj_la1[11] = jj_gen;
				break label_5;
			}
			node = sessionDeclaration();
			nodeList.add(node);
		}
		{
			if (true)
				return nodeList;
		}
		throw new Error("Missing return statement in function");
	}

	/** An imported list of Session declarations. */
	final public ArrayList importedBlockList() throws ParseException {
		ArrayList nodeList = new ArrayList(10);
		ExDesignNode node = null;
		label_6: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case BLOCK:
				;
				break;
			default:
				jj_la1[12] = jj_gen;
				break label_6;
			}
			node = blockDeclaration();
			nodeList.add(node);
		}
		{
			if (true)
				return nodeList;
		}
		throw new Error("Missing return statement in function");
	}

	/** An imported list of Trial declarations. */
	final public ArrayList importedTrialList() throws ParseException {
		ArrayList nodeList = new ArrayList(10);
		ExDesignNode node = null;
		label_7: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case TRIAL:
				;
				break;
			default:
				jj_la1[13] = jj_gen;
				break label_7;
			}
			node = trialDeclaration();
			nodeList.add(node);
		}
		{
			if (true)
				return nodeList;
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Describes a display object contained in a display list. The instance name
	 * of a display object is the display object's class name optionally
	 * followed by an arbitray instance modifier. The syntax is:
	 * 
	 * <p>
	 * display-class-name ':' instance-modifier
	 * 
	 * @throws ParseException
	 *             if there is a syntax error.
	 * @return the node of the display component declaration.
	 */
	final public ExDesignNode displayDeclaration() throws ParseException {
		DisplayIdentifier t = null;
		ExDesignNode dsp = null;
		ExDesignNode modifier = null;
		ExDesignNode pa = null;
		String[] parNames = null;
		t = displayIdentifier();
		dsp = new ExDesignNode(ExDesignNode.DisplayNode, t.getClassName(),
				null, 1);
		dsp.setTokenPosition(t.beginLine, t.beginColumn);
		dsp.setComment(t.getComment());
		dsp.setName(t.toString());
		Debug.show(Debug.PARSER, "Starting node " + dsp);
		parNames = displayListParameterIdentifierList(dsp.getName());
		dsp.setParNames(parNames);
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case 52:
			jj_consume_token(52);
			label_8: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case ADJUSTABLE:
				case IDENTIFIER:
					;
					break;
				default:
					jj_la1[14] = jj_gen;
					break label_8;
				}
				pa = displayParameterValueAssignment(dsp);
				dsp.add(pa);
			}
			jj_consume_token(53);
			break;
		case 54:
			jj_consume_token(54);
			break;
		default:
			jj_la1[15] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}
		Debug.show(Debug.PARSER, "Finished node " + dsp);
		{
			if (true)
				return (dsp);
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Collects assignments to and definitions of global experimental
	 * parameters.
	 * 
	 * <p>
	 * An assignment group starts with the keyword 'AssignmentGroup' followed by
	 * a list of runtime arguments. The block contains assignments to global
	 * experimental parameters only. Note that new global experimental
	 * parameters may be created by putting the keyword 'new' in front of an
	 * assignment. An experiment may contain more than a single assignment
	 * group.
	 * 
	 * @throws ParseException
	 *             if there is a syntax error.
	 * @return the node of the assignment group declaration.
	 */
	final public ExDesignNode assignmentGroupDeclaration()
			throws ParseException {
		Token t;
		ExDesignNode assignmentGrp = null;
		ExDesignNode a = null;
		String[] parNames = null;
		t = jj_consume_token(ASSIGNMENTGROUP);
		assignmentGrp = new ExDesignNode(ExDesignNode.AssignmentGroupNode, 10);
		assignmentGrp.setTokenPosition(t.beginLine, t.beginColumn);
		if (t.specialToken != null)
			assignmentGrp.setComment(getPrecedingComments(t));
		Debug.show(Debug.PARSER, "Begin node: " + assignmentGrp);
		parNames = parameterIdentifierList();
		assignmentGrp.setParNames(parNames);
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case 52:
			jj_consume_token(52);
			label_9: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case NEWPAR:
				case IDENTIFIER:
					;
					break;
				default:
					jj_la1[16] = jj_gen;
					break label_9;
				}
				a = globalParameterValueAssignment();
				assignmentGrp.add(a);
			}
			jj_consume_token(53);
			break;
		case 54:
			jj_consume_token(54);
			break;
		default:
			jj_la1[17] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}
		Debug.show(Debug.PARSER, "Finished node " + assignmentGrp);
		{
			if (true)
				return assignmentGrp;
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * An assignments to a global experimental parameter or the definition of a
	 * new global experimental parameter.
	 * 
	 * <p>
	 * New global experimental parameters may be created by putting the keyword
	 * 'new' in front of the assignment.
	 * 
	 * @throws ParseException
	 *             if there is a syntax error.
	 * @return the node of the assignment declaration.
	 */
	final public ExDesignNode globalParameterValueAssignment()
			throws ParseException {
		Token t;
		int nodeType = ExDesignNode.AssignmentNode;
		ExDesignNode node = null;
		String comment = null;
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case NEWPAR:
			t = jj_consume_token(NEWPAR);
			nodeType = ExDesignNode.NewParamAssignmentNode;
			if (t.specialToken != null)
				comment = getPrecedingComments(t);
			break;
		default:
			jj_la1[18] = jj_gen;
			;
		}
		node = parameterValueAssignment(null, nodeType);
		if (comment != null)
			node.setComment(comment);
		{
			if (true)
				return node;
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * An assignments to an experimental parameter of a display object.
	 * 
	 * <p>
	 * An experimental parameter may be defined as an adjustable parameter
	 * putting the keyword 'adjustable' in front of the assignment.
	 * 
	 * @throws ParseException
	 *             if there is a syntax error.
	 * @return the node of the assignment declaration.
	 */
	final public ExDesignNode displayParameterValueAssignment(ExDesignNode dsp)
			throws ParseException {
		Token t;
		int nodeType = ExDesignNode.AssignmentNode;
		ExDesignNode node = null;
		String comment = null;
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case ADJUSTABLE:
			t = jj_consume_token(ADJUSTABLE);
			nodeType = ExDesignNode.AdjustableParamAssignmentNode;
			if (t.specialToken != null)
				comment = getPrecedingComments(t);
			break;
		default:
			jj_la1[19] = jj_gen;
			;
		}
		node = parameterValueAssignment(dsp, nodeType);
		if (comment != null)
			node.setComment(comment);
		{
			if (true)
				return node;
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * A single assignment node which assigns a value to an experimental
	 * parameter. Assignments may be prefixed by the keyword 'new' in order to
	 * create a global experimental parameter.
	 * 
	 * <p>
	 * External calls: <br>
	 * EditableExDesign.changeNodeValue()
	 * 
	 * @throws ParseException
	 *             if there is a syntax error.
	 * @param dsp
	 *            the name of the display which is the parent node of this
	 *            assignment. If this is null then the assumption is that the
	 *            parameter involved is a global experimental parameter.
	 * @return the node of the assignment group declaration.
	 */
	final public ExDesignNode parameterValueAssignment(ExDesignNode dsp,
			int nodeType) throws ParseException {
		Token t, mt;
		ExParValue x;
		ExDesignNode node = null;
		String m = null;
		String name = null;
		String comment = null;
		t = jj_consume_token(IDENTIFIER);
		name = t.toString();
		if (t.specialToken != null)
			comment = getPrecedingComments(t);
		label_10: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case 58:
				;
				break;
			default:
				jj_la1[20] = jj_gen;
				break label_10;
			}
			jj_consume_token(58);
			mt = jj_consume_token(IDENTIFIER);
			name = name + "." + mt.toString();
		}
		jj_consume_token(59);
		x = assignableParameterValue();
		node = new ExDesignNode(nodeType, name, x, 0);
		node.setTokenPosition(t.beginLine, t.beginColumn);
		node.setName(name);
		node.setTypeModifier(ExDesignNode.ExplicitAssignment);
		if (comment != null)
			node.setComment(comment);
		jj_consume_token(54);
		Debug.show(Debug.PARSER, "Assignment: " + node);
		{
			if (true)
				return node;
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Defines the factorial structure of the experiment including the
	 * operationalization of each experimental factor. An experimental factors
	 * declaration starts with the keyword 'Factors' followed by an argument
	 * list and a block containing a list of factor declarations or a condition
	 * table declaration.
	 * 
	 * @throws ParseException
	 *             if there is a syntax error.
	 * @return the node of the factors declaration.
	 */
	final public ExDesignNode factorsDeclaration() throws ParseException {
		Token t;
		ExDesignNode factors = null;
		ExDesignNode node = null;
		String[] parNames = null;
		t = jj_consume_token(FACTORS);
		factors = new ExDesignNode(ExDesignNode.FactorsNode, 10);
		factors.setTokenPosition(t.beginLine, t.beginColumn);
		if (t.specialToken != null)
			factors.setComment(getPrecedingComments(t));
		Debug.show(Debug.PARSER, "Begin node: " + factors);
		parNames = parameterIdentifierList();
		factors.setParNames(parNames);
		jj_consume_token(52);
		label_11: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case RANDFACTOR:
			case INDEPFACTOR:
			case DEPFACTOR:
			case COVFACTOR:
			case CONDITIONTABLE:
				;
				break;
			default:
				jj_la1[21] = jj_gen;
				break label_11;
			}
			node = factorDeclaration();
			factors.add(node);
		}
		jj_consume_token(53);
		Debug.show(Debug.PARSER, "Finished node: " + factors);
		{
			if (true)
				return factors;
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Defines a single experimental factor and its operationalization. The
	 * declaration starts with a keyword defining the factor type followed by a
	 * list of parameter names. The first parameter defines the factor name and
	 * the following parameters define the factor's operationalization. We have
	 * random, independent, dependent, and covariate factors. An independent
	 * factor declaration may be replaced by a condition table which explicitly
	 * defines every factorial condition of the experiment. This might be
	 * necessary if there is no simple 1-1 mapping of the factor levels to
	 * values of the operationalizing experimental parameters. The argument list
	 * is followed by a block of factor level or condition declarations which
	 * define every factor level or condition.
	 * 
	 * @throws ParseException
	 *             if there is a syntax error.
	 * @return the node of the factor declaration.
	 */
	final public ExDesignNode factorDeclaration() throws ParseException {
		Token t = null;
		int type = 0;
		ExDesignNode factor = null;
		ExDesignNode level = null;
		String[] parNames = null;
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case RANDFACTOR:
			t = jj_consume_token(RANDFACTOR);
			type = ExDesignNode.RandomFactorNode;
			break;
		case INDEPFACTOR:
			t = jj_consume_token(INDEPFACTOR);
			type = ExDesignNode.IndependentFactorNode;
			break;
		case DEPFACTOR:
			t = jj_consume_token(DEPFACTOR);
			type = ExDesignNode.DependentFactorNode;
			break;
		case COVFACTOR:
			t = jj_consume_token(COVFACTOR);
			type = ExDesignNode.CovariateFactorNode;
			break;
		case CONDITIONTABLE:
			t = jj_consume_token(CONDITIONTABLE);
			type = ExDesignNode.ConditionTableNode;
			break;
		default:
			jj_la1[22] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}
		factor = new ExDesignNode(type, 1);
		factor.setTokenPosition(t.beginLine, t.beginColumn);
		if (t.specialToken != null)
			factor.setComment(getPrecedingComments(t));
		Debug.show(Debug.PARSER, "Begin node: " + factor);
		parNames = parameterIdentifierList();
		factor.setParNames(parNames);
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case 52:
			jj_consume_token(52);
			label_12: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case FACTORLEVEL:
				case CONDITION:
					;
					break;
				default:
					jj_la1[23] = jj_gen;
					break label_12;
				}
				level = factorLevelDeclaration(parNames);
				factor.add(level);
			}
			jj_consume_token(53);
			break;
		case 54:
			jj_consume_token(54);
			break;
		default:
			jj_la1[24] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}
		Debug.show(Debug.PARSER, "Finished node: " + factor);
		{
			if (true)
				return factor;
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Defines parameter values which correspond to a single factor level. The
	 * declaration starts with the keyword 'FactorLevel' or 'Condition' followed
	 * by a list of parameter values. The parameter values correspond to the
	 * parameters given in the corresponding factor or condition table
	 * declaration and define the parameter values operationalizing the
	 * respective factor level or condition.
	 * 
	 * @throws ParseException
	 *             if there is a syntax error.
	 * @param parNames
	 *            the array of parameter names for this node as given in the
	 *            argument list of the respective supernode.
	 * @return the node of the factor level or condition declaration.
	 */
	final public ExDesignNode factorLevelDeclaration(String[] parNames)
			throws ParseException {
		Token t = null;
		int nodeType = 0;
		ExParValue[] parValues;
		ExDesignNode node = null;
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case FACTORLEVEL:
			t = jj_consume_token(FACTORLEVEL);
			nodeType = ExDesignNode.FactorLevelNode;
			break;
		case CONDITION:
			t = jj_consume_token(CONDITION);
			nodeType = ExDesignNode.ConditionNode;
			break;
		default:
			jj_la1[25] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}
		parValues = assignableParameterValueList();
		node = new ExDesignNode(nodeType, parNames, parValues, 0);
		node.setTokenPosition(t.beginLine, t.beginColumn);
		if (t.specialToken != null)
			node.setComment(getPrecedingComments(t));
		jj_consume_token(54);
		Debug.show(Debug.PARSER, "Node: " + node);
		{
			if (true)
				return node;
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Read a comma separated list of runtime parameter names.
	 * 
	 * @return a String array containing the parameter names.
	 */
	final public String[] parameterIdentifierList() throws ParseException {
		ParameterIdentifier t;
		ArrayList parNames = new ArrayList(10);
		jj_consume_token(55);
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case EXPERIMENTDATA:
		case PROCEDURE:
		case PROCEDUREEND:
		case PROCEDUREDATA:
		case SESSION:
		case SESSIONEND:
		case SESSIONDATA:
		case BLOCK:
		case BLOCKEND:
		case BLOCKDATA:
		case TRIAL:
		case TRIALDATA:
		case IDENTIFIER:
			t = parameterIdentifier();
			parNames.add(t.toString());
			label_13: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case 56:
					;
					break;
				default:
					jj_la1[26] = jj_gen;
					break label_13;
				}
				jj_consume_token(56);
				t = parameterIdentifier();
				parNames.add(t.toString());
			}
			break;
		default:
			jj_la1[27] = jj_gen;
			;
		}
		jj_consume_token(57);
		parNames.trimToSize();
		{
			if (true)
				return StringExt.stringArrayOfList(parNames);
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Get a fully qualified identifier for an experimental parameter of a
	 * display object. A fully qualified name contains three parts: (1) the
	 * display list instance identifier, (2) the display instance identifier,
	 * and (3) the experimental parameter name. The three parts are separated by
	 * a period character. The first two parts are missing for global
	 * experimental parameters.
	 * 
	 * @return the fully qualified identifier.
	 */
	final public ParameterIdentifier parameterIdentifier()
			throws ParseException {
		Token t = null;
		DisplayListIdentifier n1 = null;
		DisplayIdentifier n2 = null;
		if (jj_2_1(2)) {
			n1 = displayListIdentifier();
			jj_consume_token(58);
			n2 = displayIdentifier();
			jj_consume_token(58);
		} else {
			;
		}
		t = jj_consume_token(IDENTIFIER);
		ParameterIdentifier n = new ParameterIdentifier(n1, n2, t.toString(),
				t.beginLine, t.beginColumn);
		Debug.show(Debug.PARSER, "Parameter Identifier: " + n.toString());
		{
			if (true)
				return n;
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Read a comma separated list of parameter names which are used as
	 * arguments for a display list. Some automatic extensions are possible: If
	 * the display list identifier is missing then it is inserted automatically.
	 * If both the display list and the display instance prefix are missing then
	 * the name must belong to a global parameter.
	 * 
	 * @param dln
	 *            a string which contains the name of the display list instance
	 *            whose arguments are to be read.
	 * @return the expanded parameter names in a String array.
	 */
	final public String[] displayListParameterIdentifierList(String dln)
			throws ParseException {
		ParameterIdentifier t;
		ArrayList parNames = new ArrayList(10);
		jj_consume_token(55);
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case EXPERIMENTDATA:
		case PROCEDURE:
		case PROCEDUREEND:
		case PROCEDUREDATA:
		case SESSION:
		case SESSIONEND:
		case SESSIONDATA:
		case BLOCK:
		case BLOCKEND:
		case BLOCKDATA:
		case TRIAL:
		case TRIALDATA:
		case IDENTIFIER:
			t = displayListParameterIdentifier(dln);
			parNames.add(t.toString());
			label_14: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case 56:
					;
					break;
				default:
					jj_la1[28] = jj_gen;
					break label_14;
				}
				jj_consume_token(56);
				t = displayListParameterIdentifier(dln);
				parNames.add(t.toString());
			}
			break;
		default:
			jj_la1[29] = jj_gen;
			;
		}
		jj_consume_token(57);
		parNames.trimToSize();
		{
			if (true)
				return StringExt.stringArrayOfList(parNames);
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * A parameter identifier which is used as an argument for a display list.
	 * Some automatic extensions are possible: If the display list identifier
	 * part is missing then it is inserted automatically. If both the display
	 * list and the display instance prefix are missing then the name must
	 * belong to a global parameter.
	 * 
	 * @param dlp
	 *            a string which contains the name of the display list instance
	 *            which contains this identifier in its argument list.
	 * @return the fully qualified parameter name.
	 */
	final public ParameterIdentifier displayListParameterIdentifier(String dlp)
			throws ParseException {
		Token t = null;
		DisplayIdentifier dsp = null;
		DisplayListIdentifier dspl = null;
		ParameterIdentifier cpi = null;
		int line = 0, col = 0;
		if (jj_2_3(2)) {
			if (jj_2_2(2)) {
				dspl = displayListIdentifier();
				jj_consume_token(58);
			} else {
				;
			}
			dsp = displayIdentifier();
			jj_consume_token(58);
		} else {
			;
		}
		t = jj_consume_token(IDENTIFIER);
		if ((dspl == null) && (dsp != null)) {
			dspl = new DisplayListIdentifier(dlp, null);
		}
		cpi = new ParameterIdentifier(dspl, dsp, t.toString(), line, col);
		Debug.show(Debug.PARSER,
				"Display List Parameter Identifier: " + cpi.toString());
		{
			if (true)
				return cpi;
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Get an identifyer for a runtime instance of a display list. The runtime
	 * instance of a display list name is a display list name ('ProcedureStart',
	 * 'ProcedureEnd', 'SessionStart', 'SessionEnd', 'BlockStart', 'BlockEnd',
	 * 'Trial') optionally followed by an instance modifier with a colon as a
	 * separator character like 'Session:Intro'.
	 * 
	 * @return the display list instance identifier.
	 */
	final public DisplayListIdentifier displayListIdentifier()
			throws ParseException {
		Token t1 = null, t2 = null;
		String n1 = null;
		String n2 = null;
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case PROCEDURE:
			t1 = jj_consume_token(PROCEDURE);
			break;
		case PROCEDUREEND:
			t1 = jj_consume_token(PROCEDUREEND);
			break;
		case SESSION:
			t1 = jj_consume_token(SESSION);
			break;
		case SESSIONEND:
			t1 = jj_consume_token(SESSIONEND);
			break;
		case BLOCK:
			t1 = jj_consume_token(BLOCK);
			break;
		case BLOCKEND:
			t1 = jj_consume_token(BLOCKEND);
			break;
		case TRIAL:
			t1 = jj_consume_token(TRIAL);
			break;
		case EXPERIMENTDATA:
			t1 = jj_consume_token(EXPERIMENTDATA);
			break;
		case PROCEDUREDATA:
			t1 = jj_consume_token(PROCEDUREDATA);
			break;
		case SESSIONDATA:
			t1 = jj_consume_token(SESSIONDATA);
			break;
		case BLOCKDATA:
			t1 = jj_consume_token(BLOCKDATA);
			break;
		case TRIALDATA:
			t1 = jj_consume_token(TRIALDATA);
			break;
		default:
			jj_la1[30] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}
		n1 = t1.toString();
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case 60:
			jj_consume_token(60);
			t2 = jj_consume_token(IDENTIFIER);
			n2 = t2.toString();
			break;
		default:
			jj_la1[31] = jj_gen;
			;
		}
		DisplayListIdentifier n = new DisplayListIdentifier(n1, n2,
				t1.beginLine, t1.beginColumn);
		if (t1.specialToken != null)
			n.setComment(getPrecedingComments(t1));
		Debug.show(Debug.PARSER, "DisplayList identifier: " + n.toString());
		{
			if (true)
				return n;
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Get an identifyer for a runtime instance of a display object. The runtime
	 * name of a display object is the display's class name optionally followed
	 * by an instance name using a colon as a separator character, like
	 * 'Message:Intro'.
	 * 
	 * @return the procedure unit identifier.
	 */
	final public DisplayIdentifier displayIdentifier() throws ParseException {
		Token t = null;
		String n1 = null;
		String n2 = null;
		t = jj_consume_token(IDENTIFIER);
		n1 = t.toString();
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case 60:
			jj_consume_token(60);
			t = jj_consume_token(IDENTIFIER);
			n2 = t.toString();
			break;
		default:
			jj_la1[32] = jj_gen;
			;
		}
		DisplayIdentifier n = new DisplayIdentifier(n1, n2, t.beginLine,
				t.beginColumn);
		if (t.specialToken != null)
			n.setComment(getPrecedingComments(t));
		Debug.show(Debug.PARSER, "Display identifier: " + n.toString());
		{
			if (true)
				return n;
		}
		throw new Error("Missing return statement in function");
	}

	/** Define the runtime argument values of a procedure. */
	final public ExDesignNode procedureDeclaration() throws ParseException {
		DisplayListIdentifier t;
		ExParValue[] parValues;
		ExDesignNode procedure = null;
		ExDesignNode session = null;
		Token t1 = null;
		ArrayList sessionList = null;
		t1 = jj_consume_token(PROCEDURE);
		t = new DisplayListIdentifier(t1.toString(), null, t1.beginLine,
				t1.beginColumn);
		if (t1.specialToken != null)
			t.setComment(getPrecedingComments(t1));
		Debug.show(Debug.PARSER, "Procedure Identifier: " + t.toString());
		parValues = argumentParameterValueList();
		String n = t.toString();
		int tp = t.getNodeType(false);
		if (tp < 0)
			tp = ExDesignNode.ProcedureNode;
		if (tp == ExDesignNode.ProcedureNode) {
			procedure = new ExDesignNode(ExDesignNode.ProcedureNode,
					getDisplayListParNames(n), parValues, 10);
			procedure.setName(n);
			procedure.setTokenPosition(t.beginLine, t.beginColumn);
			if (t.hasComment())
				procedure.setComment(t.getComment());
			Debug.show(Debug.PARSER, "Starting node " + procedure);
		} else {
			{
				if (true)
					throw new ParseException();
			}
		}
		jj_consume_token(52);
		label_15: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case SESSION:
			case IMPORT:
				;
				break;
			default:
				jj_la1[33] = jj_gen;
				break label_15;
			}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case SESSION:
				session = sessionDeclaration();
				procedure.add(session);
				break;
			case IMPORT:
				sessionList = importedExDesignNodeDeclarationList(SESSION_NODE);
				if (sessionList.size() > 0) {
					for (int i = 0; i < sessionList.size(); i++) {
						procedure.add((ExDesignNode) sessionList.get(i));
					}
				}
				break;
			default:
				jj_la1[34] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
		}
		jj_consume_token(53);
		Debug.show(Debug.PARSER, "Finished node: " + procedure);
		{
			if (true)
				return procedure;
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Define the runtime sequence of blocks in a session. The declaration
	 * starts with the runtime instance name of the session followed by a list
	 * of runtime arguments. The block contains the list of experimental blocks.
	 * 
	 * @return a runtime session node.
	 */
	final public ExDesignNode sessionDeclaration() throws ParseException {
		DisplayListIdentifier t;
		ExParValue[] parValues;
		ExDesignNode session;
		ExDesignNode block = null;
		Token t1 = null, t2 = null;
		String n2 = null;
		ArrayList blockList = null;
		t1 = jj_consume_token(SESSION);
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case 60:
			jj_consume_token(60);
			t2 = jj_consume_token(IDENTIFIER);
			n2 = t2.toString();
			break;
		default:
			jj_la1[35] = jj_gen;
			;
		}
		t = new DisplayListIdentifier(t1.toString(), n2, t1.beginLine,
				t1.beginColumn);
		if (t1.specialToken != null)
			t.setComment(getPrecedingComments(t1));
		Debug.show(Debug.PARSER, "Session identifier: " + t.toString());
		parValues = argumentParameterValueList();
		String n = t.toString();
		int tp = t.getNodeType(false);
		if (tp < 0)
			tp = ExDesignNode.SessionNode;
		if (tp == ExDesignNode.SessionNode) {
			session = new ExDesignNode(ExDesignNode.SessionNode,
					getDisplayListParNames(n), parValues, 10);
			session.setName(n);
			session.setTokenPosition(t.beginLine, t.beginColumn);
			if (t.hasComment())
				session.setComment(t.getComment());
			Debug.show(Debug.PARSER, "Begin node: " + session);
		} else {
			{
				if (true)
					throw new ParseException();
			}
		}
		jj_consume_token(52);
		label_16: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case BLOCK:
			case IMPORT:
				;
				break;
			default:
				jj_la1[36] = jj_gen;
				break label_16;
			}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case BLOCK:
				block = blockDeclaration();
				session.add(block);
				break;
			case IMPORT:
				blockList = importedExDesignNodeDeclarationList(BLOCK_NODE);
				if (blockList.size() > 0) {
					for (int i = 0; i < blockList.size(); i++) {
						session.add((ExDesignNode) blockList.get(i));
					}
				}
				break;
			default:
				jj_la1[37] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
		}
		jj_consume_token(53);
		Debug.show(Debug.PARSER, "Finished node: " + session);
		{
			if (true)
				return session;
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Define the runtime sequence of trials in an experimental block. The
	 * declaration starts with the runtime instance name of the block followed
	 * by a list of runtime arguments. The block contains the list of
	 * experimental trials.
	 * 
	 * @return a runtime block node.
	 */
	final public ExDesignNode blockDeclaration() throws ParseException {
		DisplayListIdentifier t;
		ExParValue[] parValues;
		ExDesignNode block;
		ExDesignNode trial = null;
		Token t1 = null, t2 = null;
		String n2 = null;
		ArrayList trialList = null;
		t1 = jj_consume_token(BLOCK);
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case 60:
			jj_consume_token(60);
			t2 = jj_consume_token(IDENTIFIER);
			n2 = t2.toString();
			break;
		default:
			jj_la1[38] = jj_gen;
			;
		}
		t = new DisplayListIdentifier(t1.toString(), n2, t1.beginLine,
				t1.beginColumn);
		if (t1.specialToken != null)
			t.setComment(getPrecedingComments(t1));
		Debug.show(Debug.PARSER, "Block identifier: " + t.toString());
		parValues = argumentParameterValueList();
		String n = t.toString();
		int tp = t.getNodeType(false);
		if (tp < 0)
			tp = ExDesignNode.BlockNode;
		if (tp == ExDesignNode.BlockNode) {
			block = new ExDesignNode(ExDesignNode.BlockNode,
					getDisplayListParNames(n), parValues, 100);
			block.setName(n);
			block.setTokenPosition(t.beginLine, t.beginColumn);
			if (t.hasComment())
				block.setComment(t.getComment());
			Debug.show(Debug.PARSER, "Starting node: " + block);
		} else {
			{
				if (true)
					throw new ParseException();
			}
		}
		jj_consume_token(52);
		label_17: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case TRIAL:
			case IMPORT:
				;
				break;
			default:
				jj_la1[39] = jj_gen;
				break label_17;
			}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case TRIAL:
				trial = trialDeclaration();
				block.add(trial);
				break;
			case IMPORT:
				trialList = importedExDesignNodeDeclarationList(TRIAL_NODE);
				if (trialList.size() > 0) {
					for (int i = 0; i < trialList.size(); i++) {
						block.add((ExDesignNode) trialList.get(i));
					}
				}
				break;
			default:
				jj_la1[40] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
		}
		jj_consume_token(53);
		Debug.show(Debug.PARSER, "Finished node: " + block);
		{
			if (true)
				return block;
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Define the runtime argument values of a trial.
	 * 
	 * @return the runtime trial node.
	 */
	final public ExDesignNode trialDeclaration() throws ParseException {
		DisplayListIdentifier t;
		ExParValue[] parValues;
		ExDesignNode trial;
		Token t1 = null, t2 = null;
		String n2 = null;
		t1 = jj_consume_token(TRIAL);
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case 60:
			jj_consume_token(60);
			t2 = jj_consume_token(IDENTIFIER);
			n2 = t2.toString();
			break;
		default:
			jj_la1[41] = jj_gen;
			;
		}
		t = new DisplayListIdentifier(t1.toString(), n2, t1.beginLine,
				t1.beginColumn);
		if (t1.specialToken != null)
			t.setComment(getPrecedingComments(t1));
		Debug.show(Debug.PARSER, "Trial identifier: " + t.toString());
		parValues = argumentParameterValueList();
		jj_consume_token(54);
		String n = t.toString();
		int tp = t.getNodeType(false);
		if (tp < 0)
			tp = ExDesignNode.TrialNode;
		if (tp == ExDesignNode.TrialNode) {
			trial = new ExDesignNode(ExDesignNode.TrialNode,
					getDisplayListParNames(n), parValues, 0);
			trial.setName(n);
			trial.setTokenPosition(t.beginLine, t.beginColumn);
			if (t.hasComment())
				trial.setComment(t.getComment());
			Debug.show(Debug.PARSER, "Node " + trial);
			{
				if (true)
					return trial;
			}
		} else {
			{
				if (true)
					throw new ParseException();
			}
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Read a comma separated list of experimental parameter values.
	 * 
	 * @return an array of parameter values.
	 */
	final public ExParValue[] assignableParameterValueList()
			throws ParseException {
		ArrayList nl = new ArrayList(10);
		ExParValue x;
		jj_consume_token(55);
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case EXPERIMENTDATA:
		case PROCEDURE:
		case PROCEDUREEND:
		case PROCEDUREDATA:
		case SESSION:
		case SESSIONEND:
		case SESSIONDATA:
		case BLOCK:
		case BLOCKEND:
		case BLOCKDATA:
		case TRIAL:
		case TRIALDATA:
		case TRUE:
		case FALSE:
		case INTEGER_LITERAL:
		case FLOATING_POINT_LITERAL:
		case STRING_LITERAL:
		case IDENTIFIER:
		case 55:
		case 62:
		case 64:
		case 66:
		case 67:
		case 68:
		case 69:
		case 70:
		case 86:
		case 87:
			x = assignableParameterValue();
			nl.add(x);
			label_18: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case 56:
					;
					break;
				default:
					jj_la1[42] = jj_gen;
					break label_18;
				}
				jj_consume_token(56);
				x = assignableParameterValue();
				nl.add(x);
			}
			break;
		default:
			jj_la1[43] = jj_gen;
			;
		}
		jj_consume_token(57);
		ExParValue pa[] = new ExParValue[nl.size()];
		for (int i = 0; i < pa.length; i++) {
			pa[i] = (ExParValue) nl.get(i);
		}
		Debug.show(Debug.PARSER, "Assignable parameter value list: "
				+ ExParValue.stringOf(pa));
		{
			if (true)
				return pa;
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Read a comma separated list of experimental parameter values.
	 * 
	 * @return an array of parameter values.
	 */
	final public ExParValue[] argumentParameterValueList()
			throws ParseException {
		ArrayList nl = new ArrayList(10);
		ExParValue x;
		jj_consume_token(55);
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case EXPERIMENTDATA:
		case PROCEDURE:
		case PROCEDUREEND:
		case PROCEDUREDATA:
		case SESSION:
		case SESSIONEND:
		case SESSIONDATA:
		case BLOCK:
		case BLOCKEND:
		case BLOCKDATA:
		case TRIAL:
		case TRIALDATA:
		case TRUE:
		case FALSE:
		case INTEGER_LITERAL:
		case FLOATING_POINT_LITERAL:
		case STRING_LITERAL:
		case IDENTIFIER:
		case 55:
		case 61:
		case 62:
		case 64:
		case 66:
		case 67:
		case 68:
		case 69:
		case 70:
		case 86:
		case 87:
			x = argumentParameterValue();
			nl.add(x);
			label_19: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case 56:
					;
					break;
				default:
					jj_la1[44] = jj_gen;
					break label_19;
				}
				jj_consume_token(56);
				x = argumentParameterValue();
				nl.add(x);
			}
			break;
		default:
			jj_la1[45] = jj_gen;
			;
		}
		jj_consume_token(57);
		ExParValue pa[] = new ExParValue[nl.size()];
		for (int i = 0; i < pa.length; i++) {
			pa[i] = (ExParValue) nl.get(i);
		}
		Debug.show(Debug.PARSER,
				"Argument parameter value list: " + ExParValue.stringOf(pa));
		{
			if (true)
				return pa;
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Read a single experimental parameter value. A parameter value can appear
	 * on the right side of an assignment or in an argument list of a display
	 * list node in the procedure section. It may be a place holder for the
	 * default parameter value, an array of constant values, a replicator array,
	 * or an expression.
	 * 
	 * <p>
	 * This method is both used internally and externally.
	 * 
	 * <p>
	 * External calls: <br>
	 * ExPar.loadDefaults() <br>
	 * de.pxlab.pxl.design.ConditionTableModel.setValueAt()
	 * 
	 * @return the experimental parameter value.
	 */
	final public ExParValue assignableParameterValue() throws ParseException {
		ExParValue x;
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case 62:
			x = array();
			break;
		case 64:
			x = replicator();
			break;
		case EXPERIMENTDATA:
		case PROCEDURE:
		case PROCEDUREEND:
		case PROCEDUREDATA:
		case SESSION:
		case SESSIONEND:
		case SESSIONDATA:
		case BLOCK:
		case BLOCKEND:
		case BLOCKDATA:
		case TRIAL:
		case TRIALDATA:
		case TRUE:
		case FALSE:
		case INTEGER_LITERAL:
		case FLOATING_POINT_LITERAL:
		case STRING_LITERAL:
		case IDENTIFIER:
		case 55:
		case 66:
		case 67:
		case 68:
		case 69:
		case 70:
		case 86:
		case 87:
			x = expression();
			break;
		default:
			jj_la1[46] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}
		{
			if (true)
				return (x);
		}
		throw new Error("Missing return statement in function");
	}

	final public ExParValue argumentParameterValue() throws ParseException {
		ExParValue x;
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case 61:
			x = defaultValue();
			break;
		case EXPERIMENTDATA:
		case PROCEDURE:
		case PROCEDUREEND:
		case PROCEDUREDATA:
		case SESSION:
		case SESSIONEND:
		case SESSIONDATA:
		case BLOCK:
		case BLOCKEND:
		case BLOCKDATA:
		case TRIAL:
		case TRIALDATA:
		case TRUE:
		case FALSE:
		case INTEGER_LITERAL:
		case FLOATING_POINT_LITERAL:
		case STRING_LITERAL:
		case IDENTIFIER:
		case 55:
		case 62:
		case 64:
		case 66:
		case 67:
		case 68:
		case 69:
		case 70:
		case 86:
		case 87:
			x = assignableParameterValue();
			break;
		default:
			jj_la1[47] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}
		{
			if (true)
				return (x);
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Read the place holder for a parameter's default value symbolized by a
	 * question mark. A parameter's default value is the value defined in its
	 * nearest enclosing scope.
	 * 
	 * @return an experimental parameter value marked as having its default
	 *         value.
	 */
	final public ExParValue defaultValue() throws ParseException {
		jj_consume_token(61);
		{
			if (true)
				return (new ExParValueUndefined());
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Read an array valued experimental parameter value. Array valued parameter
	 * values may only contain immediate constant values. Parameter names and
	 * expressions are not allowed as array elements.
	 * 
	 * @return the experimental parameter value.
	 */
	final public ExParValue array() throws ParseException {
		ExParValue[] sa = null;
		jj_consume_token(62);
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case EXPERIMENTDATA:
		case PROCEDURE:
		case PROCEDUREEND:
		case PROCEDUREDATA:
		case SESSION:
		case SESSIONEND:
		case SESSIONDATA:
		case BLOCK:
		case BLOCKEND:
		case BLOCKDATA:
		case TRIAL:
		case TRIALDATA:
		case TRUE:
		case FALSE:
		case INTEGER_LITERAL:
		case FLOATING_POINT_LITERAL:
		case STRING_LITERAL:
		case IDENTIFIER:
		case 66:
		case 67:
		case 68:
		case 69:
		case 70:
			sa = constantValueList();
			break;
		default:
			jj_la1[48] = jj_gen;
			;
		}
		jj_consume_token(63);
		{
			if (true)
				return (sa == null) ? new ExParValueUndefined() : ExParValue
						.constantExParValue(sa);
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Read a replicator array as a parameter value. A replicator array valued
	 * parameter in a trial argument list generates a series of trials which
	 * have the replicator entries as values of the respective parameter.
	 * 
	 * @return an experimental parameter value.
	 */
	final public ExParValue replicator() throws ParseException {
		ExParValue[] sa;
		jj_consume_token(64);
		sa = constantValueList();
		jj_consume_token(65);
		ExParValue x = ExParValue.constantExParValue(sa);
		x.setExpansion();
		{
			if (true)
				return x;
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Read a comma separated list of parameter values which are constant and
	 * defined at compile time. These are contents of array or replicator
	 * objects.
	 * 
	 * @return an array containing the constnat ExParValue objects.
	 */
	final public ExParValue[] constantValueList() throws ParseException {
		ArrayList exlist = new ArrayList();
		ExParValue s;
		s = constantValue();
		exlist.add(s);
		label_20: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case 56:
				;
				break;
			default:
				jj_la1[49] = jj_gen;
				break label_20;
			}
			jj_consume_token(56);
			s = constantValue();
			exlist.add(s);
		}
		exlist.trimToSize();
		int n = exlist.size();
		ExParValue sa[] = new ExParValue[n];
		for (int i = 0; i < n; i++) {
			sa[i] = (ExParValue) (exlist.get(i));
		}
		{
			if (true)
				return sa;
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Read a constant parameter values. These are class constants addressed by
	 * their symbolic names or signed literals.
	 * 
	 * @return an ExParValue object containing the constant value.
	 */
	final public ExParValue constantValue() throws ParseException {
		ExParValue s;
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case EXPERIMENTDATA:
		case PROCEDURE:
		case PROCEDUREEND:
		case PROCEDUREDATA:
		case SESSION:
		case SESSIONEND:
		case SESSIONDATA:
		case BLOCK:
		case BLOCKEND:
		case BLOCKDATA:
		case TRIAL:
		case TRIALDATA:
		case IDENTIFIER:
		case 66:
		case 67:
		case 68:
			s = valueIdentifier(true);
			break;
		case TRUE:
		case FALSE:
		case INTEGER_LITERAL:
		case FLOATING_POINT_LITERAL:
		case STRING_LITERAL:
		case 69:
		case 70:
			s = signedLiteral();
			break;
		default:
			jj_la1[50] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}
		{
			if (true)
				return s;
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Read a value identifier. This is a symbolic name of an ExParValue. It may
	 * either be the name of a class constant or it may be the instance name of
	 * an experimental parameter.
	 * 
	 * @param constOnly
	 *            if true then only names which represent class constants are
	 *            accepted.
	 */
	final public ExParValue valueIdentifier(boolean constOnly)
			throws ParseException {
		Token s, t;
		String p = null;
		DisplayIdentifier di = null;
		DisplayListIdentifier dli = null;
		ExParValue x = null;
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case EXPERIMENTDATA:
		case PROCEDURE:
		case PROCEDUREEND:
		case PROCEDUREDATA:
		case SESSION:
		case SESSIONEND:
		case SESSIONDATA:
		case BLOCK:
		case BLOCKEND:
		case BLOCKDATA:
		case TRIAL:
		case TRIALDATA:
		case 66:
		case 67:
		case 68:
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case 66:
			case 67:
			case 68:
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case 66:
					jj_consume_token(66);
					p = "de.pxlab.";
					break;
				case 67:
					jj_consume_token(67);
					p = "java.";
					break;
				case 68:
					jj_consume_token(68);
					p = "javax.";
					break;
				default:
					jj_la1[51] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
				label_21: while (true) {
					if (jj_2_4(2)) {
						;
					} else {
						break label_21;
					}
					s = jj_consume_token(IDENTIFIER);
					jj_consume_token(58);
					p = p + s.toString() + ".";
				}
				break;
			case EXPERIMENTDATA:
			case PROCEDURE:
			case PROCEDUREEND:
			case PROCEDUREDATA:
			case SESSION:
			case SESSIONEND:
			case SESSIONDATA:
			case BLOCK:
			case BLOCKEND:
			case BLOCKDATA:
			case TRIAL:
			case TRIALDATA:
				dli = displayListIdentifier();
				jj_consume_token(58);
				di = displayIdentifier();
				jj_consume_token(58);
				break;
			default:
				jj_la1[52] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			break;
		default:
			jj_la1[53] = jj_gen;
			;
		}
		t = jj_consume_token(IDENTIFIER);
		if ((p != null) || ExParValue.isClassConstant(t.toString())) {
			String n = (p != null) ? (p + t.toString()) : t.toString();
			x = new ExParValueConstant(n);
		} else {
			if (constOnly) {
				new ParameterValueError("Semantic error in line " + t.beginLine
						+ ", column " + t.beginColumn + ": Parameter names ("
						+ t.toString() + ") can't be members of arrays.");
				x = new ExParValue(0);
			} else {
				ParameterIdentifier pn = new ParameterIdentifier(dli, di,
						t.toString(), t.beginLine, t.beginColumn);
				x = new ExParValueVar(pn.toString());
			}
		}
		{
			if (true)
				return x;
		}
		throw new Error("Missing return statement in function");
	}

	/** Read an optionally signed literal value. */
	final public ExParValue signedLiteral() throws ParseException {
		boolean negate = false;
		ExParValue x = null;
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case 69:
		case 70:
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case 69:
				jj_consume_token(69);
				break;
			case 70:
				jj_consume_token(70);
				negate = true;
				break;
			default:
				jj_la1[54] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			break;
		default:
			jj_la1[55] = jj_gen;
			;
		}
		x = literal();
		{
			if (true)
				return negate ? x.neg() : x;
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * An expression of parameter values.
	 * 
	 * <p>
	 * Expressions may not contain array values and experimental parameters
	 * which appear in expressions may not have array values.
	 * 
	 * <p>
	 * Expressions are stored in an ExParValue as an expression tree and are
	 * evaluated only at runtime whenever the value of the respective parameter
	 * is required.
	 * 
	 * @return an experimental parameter value which contains the expression.
	 */
	final public ExParValue expression() throws ParseException {
		ExParValue r = null, x, y, z;
		x = conditionalOrExpression();
		r = x;
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case 61:
			jj_consume_token(61);
			y = expression();
			jj_consume_token(60);
			z = expression();
			r = new ExParValue(new ExParExpression(
					ExParExpression.CONDITIONAL_OP), x, y, z);
			break;
		default:
			jj_la1[56] = jj_gen;
			;
		}
		{
			if (true)
				return r;
		}
		throw new Error("Missing return statement in function");
	}

	final public ExParValue conditionalOrExpression() throws ParseException {
		ExParValue x, y;
		x = conditionalAndExpression();
		label_22: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case 71:
				;
				break;
			default:
				jj_la1[57] = jj_gen;
				break label_22;
			}
			jj_consume_token(71);
			y = conditionalAndExpression();
			x = new ExParValue(new ExParExpression(ExParExpression.OR_OP), x,
					y, null);
		}
		{
			if (true)
				return x;
		}
		throw new Error("Missing return statement in function");
	}

	final public ExParValue conditionalAndExpression() throws ParseException {
		ExParValue x, y;
		x = inclusiveOrExpression();
		label_23: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case 72:
				;
				break;
			default:
				jj_la1[58] = jj_gen;
				break label_23;
			}
			jj_consume_token(72);
			y = inclusiveOrExpression();
			x = new ExParValue(new ExParExpression(ExParExpression.AND_OP), x,
					y, null);
		}
		{
			if (true)
				return x;
		}
		throw new Error("Missing return statement in function");
	}

	final public ExParValue inclusiveOrExpression() throws ParseException {
		ExParValue x, y;
		x = exclusiveOrExpression();
		label_24: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case 73:
				;
				break;
			default:
				jj_la1[59] = jj_gen;
				break label_24;
			}
			jj_consume_token(73);
			y = exclusiveOrExpression();
			x = new ExParValue(new ExParExpression(ExParExpression.BIN_OR_OP),
					x, y, null);
		}
		{
			if (true)
				return x;
		}
		throw new Error("Missing return statement in function");
	}

	final public ExParValue exclusiveOrExpression() throws ParseException {
		ExParValue x, y;
		x = andExpression();
		label_25: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case 74:
				;
				break;
			default:
				jj_la1[60] = jj_gen;
				break label_25;
			}
			jj_consume_token(74);
			y = andExpression();
			x = new ExParValue(new ExParExpression(ExParExpression.BIN_XOR_OP),
					x, y, null);
		}
		{
			if (true)
				return x;
		}
		throw new Error("Missing return statement in function");
	}

	final public ExParValue andExpression() throws ParseException {
		ExParValue x, y;
		x = equalityExpression();
		label_26: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case 75:
				;
				break;
			default:
				jj_la1[61] = jj_gen;
				break label_26;
			}
			jj_consume_token(75);
			y = equalityExpression();
			x = new ExParValue(new ExParExpression(ExParExpression.BIN_AND_OP),
					x, y, null);
		}
		{
			if (true)
				return x;
		}
		throw new Error("Missing return statement in function");
	}

	final public ExParValue equalityExpression() throws ParseException {
		ExParValue x, y;
		int opCode;
		x = relationalExpression();
		label_27: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case 76:
			case 77:
				;
				break;
			default:
				jj_la1[62] = jj_gen;
				break label_27;
			}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case 76:
				jj_consume_token(76);
				opCode = ExParExpression.EQ_OP;
				break;
			case 77:
				jj_consume_token(77);
				opCode = ExParExpression.NE_OP;
				break;
			default:
				jj_la1[63] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			y = relationalExpression();
			x = new ExParValue(new ExParExpression(opCode), x, y, null);
		}
		{
			if (true)
				return x;
		}
		throw new Error("Missing return statement in function");
	}

	final public ExParValue relationalExpression() throws ParseException {
		ExParValue x, y;
		int opCode;
		x = shiftExpression();
		label_28: while (true) {
			if (jj_2_5(2)) {
				;
			} else {
				break label_28;
			}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case 64:
				jj_consume_token(64);
				opCode = ExParExpression.LT_OP;
				break;
			case 65:
				jj_consume_token(65);
				opCode = ExParExpression.GT_OP;
				break;
			case 78:
				jj_consume_token(78);
				opCode = ExParExpression.LE_OP;
				break;
			case 79:
				jj_consume_token(79);
				opCode = ExParExpression.GE_OP;
				break;
			default:
				jj_la1[64] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			y = shiftExpression();
			x = new ExParValue(new ExParExpression(opCode), x, y, null);
		}
		{
			if (true)
				return x;
		}
		throw new Error("Missing return statement in function");
	}

	final public ExParValue shiftExpression() throws ParseException {
		ExParValue x, y;
		int opCode;
		x = additiveExpression();
		label_29: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case 80:
			case 81:
			case 82:
				;
				break;
			default:
				jj_la1[65] = jj_gen;
				break label_29;
			}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case 80:
				jj_consume_token(80);
				opCode = ExParExpression.SHIFT_LEFT_OP;
				break;
			case 81:
				jj_consume_token(81);
				opCode = ExParExpression.SHIFT_RIGHT_OP;
				break;
			case 82:
				jj_consume_token(82);
				opCode = ExParExpression.SHIFT_RIGHT_UNSIGNED_OP;
				break;
			default:
				jj_la1[66] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			y = additiveExpression();
			x = new ExParValue(new ExParExpression(opCode), x, y, null);
		}
		{
			if (true)
				return x;
		}
		throw new Error("Missing return statement in function");
	}

	final public ExParValue additiveExpression() throws ParseException {
		ExParValue x, y;
		int opCode;
		x = multiplicativeExpression();
		label_30: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case 69:
			case 70:
				;
				break;
			default:
				jj_la1[67] = jj_gen;
				break label_30;
			}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case 69:
				jj_consume_token(69);
				opCode = ExParExpression.ADD_OP;
				break;
			case 70:
				jj_consume_token(70);
				opCode = ExParExpression.SUB_OP;
				break;
			default:
				jj_la1[68] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			y = multiplicativeExpression();
			x = new ExParValue(new ExParExpression(opCode), x, y, null);
		}
		{
			if (true)
				return x;
		}
		throw new Error("Missing return statement in function");
	}

	final public ExParValue multiplicativeExpression() throws ParseException {
		ExParValue x, y;
		int opCode;
		x = unaryExpression();
		label_31: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case 83:
			case 84:
			case 85:
				;
				break;
			default:
				jj_la1[69] = jj_gen;
				break label_31;
			}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case 83:
				jj_consume_token(83);
				opCode = ExParExpression.MUL_OP;
				break;
			case 84:
				jj_consume_token(84);
				opCode = ExParExpression.DIV_OP;
				break;
			case 85:
				jj_consume_token(85);
				opCode = ExParExpression.MOD_OP;
				break;
			default:
				jj_la1[70] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			y = unaryExpression();
			x = new ExParValue(new ExParExpression(opCode), x, y, null);
		}
		{
			if (true)
				return x;
		}
		throw new Error("Missing return statement in function");
	}

	final public ExParValue unaryExpression() throws ParseException {
		ExParValue x;
		int opCode = 0;
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case 69:
		case 70:
		case 86:
		case 87:
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case 69:
				jj_consume_token(69);
				opCode = ExParExpression.POS_OP;
				break;
			case 70:
				jj_consume_token(70);
				opCode = ExParExpression.NEG_OP;
				break;
			case 86:
				jj_consume_token(86);
				opCode = ExParExpression.BIN_COMPLEMENT_OP;
				break;
			case 87:
				jj_consume_token(87);
				opCode = ExParExpression.NOT_OP;
				break;
			default:
				jj_la1[71] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			x = unaryExpression();
			x = new ExParValue(new ExParExpression(opCode), x, null, null);
			break;
		case EXPERIMENTDATA:
		case PROCEDURE:
		case PROCEDUREEND:
		case PROCEDUREDATA:
		case SESSION:
		case SESSIONEND:
		case SESSIONDATA:
		case BLOCK:
		case BLOCKEND:
		case BLOCKDATA:
		case TRIAL:
		case TRIALDATA:
		case TRUE:
		case FALSE:
		case INTEGER_LITERAL:
		case FLOATING_POINT_LITERAL:
		case STRING_LITERAL:
		case IDENTIFIER:
		case 55:
		case 66:
		case 67:
		case 68:
			x = primaryExpression();
			break;
		default:
			jj_la1[72] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}
		{
			if (true)
				return x;
		}
		throw new Error("Missing return statement in function");
	}

	final public ExParValue primaryExpression() throws ParseException {
		ExParValue x = null;
		ExParValue y = null;
		String s;
		Token t;
		ExParValue[] ax;
		ParameterIdentifier pn;
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case TRUE:
		case FALSE:
		case INTEGER_LITERAL:
		case FLOATING_POINT_LITERAL:
		case STRING_LITERAL:
			x = literal();
			break;
		default:
			jj_la1[73] = jj_gen;
			if (jj_2_6(2)) {
				t = jj_consume_token(IDENTIFIER);
				ax = assignableParameterValueList();
				ExParValue a = null, b = null, c = null;
				if (ax != null) {
					if (ax.length >= 1) {
						a = ax[0];
					}
					if (ax.length >= 2) {
						b = ax[1];
					}
					if (ax.length >= 3) {
						c = ax[2];
					}
				}
				x = new ExParValue(new ExParExpression(
						ExParExpression.opCodeFor(t.toString())), a, b, c);
			} else {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case EXPERIMENTDATA:
				case PROCEDURE:
				case PROCEDUREEND:
				case PROCEDUREDATA:
				case SESSION:
				case SESSIONEND:
				case SESSIONDATA:
				case BLOCK:
				case BLOCKEND:
				case BLOCKDATA:
				case TRIAL:
				case TRIALDATA:
				case IDENTIFIER:
				case 66:
				case 67:
				case 68:
					x = valueIdentifier(false);
					break;
				case 55:
					jj_consume_token(55);
					y = expression();
					jj_consume_token(57);
					x = new ExParValue(new ExParExpression(
							ExParExpression.BRACKET_OP), y, null, null);
					break;
				default:
					jj_la1[74] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			}
		}
		{
			if (true)
				return (x);
		}
		throw new Error("Missing return statement in function");
	}

	final public ExParValue literal() throws ParseException {
		Token t;
		ExParValue x;
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case INTEGER_LITERAL:
			t = jj_consume_token(INTEGER_LITERAL);
			int i = 0;
			try {
				i = Integer.parseInt(t.toString());
			} catch (NumberFormatException nfx) {
			}
			x = new ExParValue(i);
			break;
		case FLOATING_POINT_LITERAL:
			t = jj_consume_token(FLOATING_POINT_LITERAL);
			double d = 0.0;
			try {
				d = Double.valueOf(t.toString()).doubleValue();
			} catch (NumberFormatException nfx) {
			}
			x = new ExParValue(d);
			break;
		case STRING_LITERAL:
			t = jj_consume_token(STRING_LITERAL);
			x = new ExParValue(StringExt.unquoteHTML(t.toString()));
			break;
		case TRUE:
			t = jj_consume_token(TRUE);
			x = new ExParValue(1);
			break;
		case FALSE:
			t = jj_consume_token(FALSE);
			x = new ExParValue(0);
			break;
		default:
			jj_la1[75] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}
		{
			if (true)
				return x;
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Read a single line of input containing the definition of an experimental
	 * design node including its list of arguments. The list of arguments is a
	 * comma separated list of experimental parameter names.
	 * <p>
	 * This method is used by the experimental design tree editor to parse
	 * edited text lines.
	 * 
	 * <p>
	 * External calls: <br>
	 * EditableExDesign.changeNodeValue()
	 * 
	 * @return and experimental design node of the respective type with
	 *         arguments being defined.
	 */
	final public ExDesignNode parNamesDefinition() throws ParseException {
		Token t = null;
		int type = 0;
		ExDesignNode node = null;
		String[] parNames = null;
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case EXPERIMENT:
			t = jj_consume_token(EXPERIMENT);
			type = ExDesignNode.ExperimentNode;
			break;
		case CONTEXT:
			t = jj_consume_token(CONTEXT);
			type = ExDesignNode.ContextNode;
			break;
		case FACTORS:
			t = jj_consume_token(FACTORS);
			type = ExDesignNode.FactorsNode;
			break;
		case ASSIGNMENTGROUP:
			t = jj_consume_token(ASSIGNMENTGROUP);
			type = ExDesignNode.AssignmentGroupNode;
			break;
		case RANDFACTOR:
			t = jj_consume_token(RANDFACTOR);
			type = ExDesignNode.RandomFactorNode;
			break;
		case INDEPFACTOR:
			t = jj_consume_token(INDEPFACTOR);
			type = ExDesignNode.IndependentFactorNode;
			break;
		case DEPFACTOR:
			t = jj_consume_token(DEPFACTOR);
			type = ExDesignNode.DependentFactorNode;
			break;
		case COVFACTOR:
			t = jj_consume_token(COVFACTOR);
			type = ExDesignNode.CovariateFactorNode;
			break;
		case CONDITIONTABLE:
			t = jj_consume_token(CONDITIONTABLE);
			type = ExDesignNode.ConditionTableNode;
			break;
		default:
			jj_la1[76] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}
		parNames = parameterIdentifierList();
		node = new ExDesignNode(type, parNames, null, 0);
		node.setTokenPosition(t.beginLine, t.beginColumn);
		Debug.show(Debug.PARSER, "Node: " + node);
		{
			if (true)
				return node;
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Read a single line of input containing the definition of an experimental
	 * design node including its list of arguments. The list of arguments is a
	 * comma separated list of experimental parameter names.
	 * <p>
	 * This method is used by the experimental design tree editor to parse
	 * edited text lines.
	 * 
	 * <p>
	 * External calls: <br>
	 * EditableExDesign.changeNodeValue()
	 * 
	 * @return and experimental design node of the respective type with
	 *         arguments being defined.
	 */
	final public ExDesignNode displayListParNamesDefinition()
			throws ParseException {
		DisplayListIdentifier pt;
		int type = 0;
		ExDesignNode node = null;
		String[] parNames = null;
		String n = null;
		pt = displayListIdentifier();
		n = pt.toString();
		int id = pt.getNodeType(true);
		if (id >= 0) {
			type = id;
		} else {
			{
				if (true)
					throw new ParseException();
			}
		}
		parNames = displayListParameterIdentifierList(n);
		node = new ExDesignNode(type, parNames, null, 0);
		node.setTokenPosition(pt.beginLine, pt.beginColumn);
		if (n != null)
			node.setName(n);
		Debug.show(Debug.PARSER, "Node: " + node);
		{
			if (true)
				return node;
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Read a single line of input containing the definition of an experimental
	 * design node including its list of argument values. The list of argument
	 * values is a comma separated list of experimental parameter values.
	 * 
	 * This method is used by the experimental design tree editor to parse
	 * edited text lines.
	 * 
	 * <p>
	 * External calls: <br>
	 * EditableExDesign.changeNodeValue()
	 * 
	 * @return and experimental design node of the respective type with argument
	 *         values being defined.
	 */
	final public ExDesignNode assignableParameterValueListDefinition()
			throws ParseException {
		Token t = null;
		DisplayListIdentifier pt;
		int type = 0;
		ExParValue[] parValues;
		ExDesignNode node = null;
		String n = null;
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case FACTORLEVEL:
			t = jj_consume_token(FACTORLEVEL);
			type = ExDesignNode.FactorLevelNode;
			break;
		case CONDITION:
			t = jj_consume_token(CONDITION);
			type = ExDesignNode.ConditionNode;
			break;
		default:
			jj_la1[77] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}
		parValues = assignableParameterValueList();
		node = new ExDesignNode(type, null, parValues, 0);
		node.setTokenPosition(t.beginLine, t.beginColumn);
		Debug.show(Debug.PARSER, "Node: " + node);
		{
			if (true)
				return node;
		}
		throw new Error("Missing return statement in function");
	}

	final public ExDesignNode argumentParameterValueListDefinition()
			throws ParseException {
		Token t = null;
		DisplayListIdentifier pt;
		int type = 0;
		ExParValue[] parValues;
		ExDesignNode node = null;
		String n = null;
		pt = displayListIdentifier();
		n = pt.toString();
		int id = pt.getNodeType(false);
		if (id >= 0) {
			type = id;
		} else {
			{
				if (true)
					throw new ParseException();
			}
		}
		t = new Token();
		t.beginLine = pt.beginLine;
		t.beginColumn = pt.beginColumn;
		parValues = argumentParameterValueList();
		node = new ExDesignNode(type, null, parValues, 0);
		node.setTokenPosition(t.beginLine, t.beginColumn);
		node.setName(n);
		Debug.show(Debug.PARSER, "Node: " + node);
		{
			if (true)
				return node;
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Read a single line of input containing the definition of a display object
	 * instance name.
	 * 
	 * This method is used by the experimental design tree editor to parse
	 * edited text lines.
	 * 
	 * <p>
	 * External calls: <br>
	 * EditableExDesign.changeNodeValue()
	 * 
	 * @return and experimental design node for the given display instynce.
	 */
	final public ExDesignNode displayDefinition() throws ParseException {
		DisplayIdentifier t = null;
		ExDesignNode node = null;
		t = displayIdentifier();
		jj_consume_token(55);
		jj_consume_token(57);
		node = new ExDesignNode(ExDesignNode.DisplayNode, t.toString(), null, 0);
		node.setTokenPosition(t.beginLine, t.beginColumn);
		Debug.show(Debug.PARSER, "Node: " + node);
		{
			if (true)
				return node;
		}
		throw new Error("Missing return statement in function");
	}

	/**
	 * Assume that the input stream of this parser is a list of assignments and
	 * create a list of parameter value assignment nodes. The assignment nodes
	 * become children of the node given as an argument. This is used by the
	 * ExDesign class to parse command line assignments.
	 * 
	 * <p>
	 * For external access only.
	 * <p>
	 * External calls: <pr>ExDesign.runtimeAssignmentsList()
	 * 
	 * @throws ParseException
	 *             if there is a syntax error.
	 * @param ex
	 *            the node which gets the list of assignments appended as its
	 *            children.
	 */
	final public void createListOfAssignments(ExDesignNode ex)
			throws ParseException {
		ExDesignNode a;
		label_32: while (true) {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case IDENTIFIER:
				;
				break;
			default:
				jj_la1[78] = jj_gen;
				break label_32;
			}
			a = parameterValueAssignment(null, ExDesignNode.AssignmentNode);
			ex.add(a);
		}
	}

	/**
	 * Read an experimental parameter value which is known to be a literal
	 * value. Assumes that the input stream contains only a single literal
	 * experimental parameter value and parses it into an ExParValue object.
	 * 
	 * <P>
	 * Used for external access only.
	 * <p>
	 * External calls: <br>
	 * ExParValue.parsed()
	 * 
	 * @return the experimental parameter value.
	 */
	final public ExParValue runtimeParameterValue() throws ParseException {
		ExParValue x;
		switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
		case TRUE:
		case FALSE:
		case INTEGER_LITERAL:
		case FLOATING_POINT_LITERAL:
		case STRING_LITERAL:
		case 69:
		case 70:
			x = signedLiteral();
			break;
		case 62:
			x = array();
			break;
		default:
			jj_la1[79] = jj_gen;
			jj_consume_token(-1);
			throw new ParseException();
		}
		{
			if (true)
				return x;
		}
		throw new Error("Missing return statement in function");
	}

	final private boolean jj_2_1(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_1();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(0, xla);
		}
	}

	final private boolean jj_2_2(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_2();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(1, xla);
		}
	}

	final private boolean jj_2_3(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_3();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(2, xla);
		}
	}

	final private boolean jj_2_4(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_4();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(3, xla);
		}
	}

	final private boolean jj_2_5(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_5();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(4, xla);
		}
	}

	final private boolean jj_2_6(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_6();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(5, xla);
		}
	}

	final private boolean jj_3R_53() {
		if (jj_3R_56())
			return true;
		return false;
	}

	final private boolean jj_3R_65() {
		if (jj_3R_33())
			return true;
		return false;
	}

	final private boolean jj_3_4() {
		if (jj_scan_token(IDENTIFIER))
			return true;
		if (jj_scan_token(58))
			return true;
		return false;
	}

	final private boolean jj_3R_66() {
		if (jj_scan_token(66))
			return true;
		return false;
	}

	final private boolean jj_3R_52() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_53()) {
			jj_scanpos = xsp;
			if (jj_3_6()) {
				jj_scanpos = xsp;
				if (jj_3R_54()) {
					jj_scanpos = xsp;
					if (jj_3R_55())
						return true;
				}
			}
		}
		return false;
	}

	final private boolean jj_3R_34() {
		if (jj_scan_token(IDENTIFIER))
			return true;
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_42())
			jj_scanpos = xsp;
		return false;
	}

	final private boolean jj_3R_64() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_66()) {
			jj_scanpos = xsp;
			if (jj_3R_67()) {
				jj_scanpos = xsp;
				if (jj_3R_68())
					return true;
			}
		}
		return false;
	}

	final private boolean jj_3R_63() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_64()) {
			jj_scanpos = xsp;
			if (jj_3R_65())
				return true;
		}
		return false;
	}

	final private boolean jj_3R_43() {
		if (jj_3R_44())
			return true;
		return false;
	}

	final private boolean jj_3R_57() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_63())
			jj_scanpos = xsp;
		if (jj_scan_token(IDENTIFIER))
			return true;
		return false;
	}

	final private boolean jj_3R_47() {
		if (jj_3R_52())
			return true;
		return false;
	}

	final private boolean jj_3R_51() {
		if (jj_scan_token(87))
			return true;
		return false;
	}

	final private boolean jj_3R_50() {
		if (jj_scan_token(86))
			return true;
		return false;
	}

	final private boolean jj_3R_62() {
		if (jj_scan_token(FALSE))
			return true;
		return false;
	}

	final private boolean jj_3R_41() {
		if (jj_scan_token(60))
			return true;
		return false;
	}

	final private boolean jj_3R_49() {
		if (jj_scan_token(70))
			return true;
		return false;
	}

	final private boolean jj_3R_61() {
		if (jj_scan_token(TRUE))
			return true;
		return false;
	}

	final private boolean jj_3R_40() {
		if (jj_scan_token(55))
			return true;
		return false;
	}

	final private boolean jj_3R_48() {
		if (jj_scan_token(69))
			return true;
		return false;
	}

	final private boolean jj_3R_60() {
		if (jj_scan_token(STRING_LITERAL))
			return true;
		return false;
	}

	final private boolean jj_3_1() {
		if (jj_3R_33())
			return true;
		if (jj_scan_token(58))
			return true;
		return false;
	}

	final private boolean jj_3R_46() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_48()) {
			jj_scanpos = xsp;
			if (jj_3R_49()) {
				jj_scanpos = xsp;
				if (jj_3R_50()) {
					jj_scanpos = xsp;
					if (jj_3R_51())
						return true;
				}
			}
		}
		return false;
	}

	final private boolean jj_3R_68() {
		if (jj_scan_token(68))
			return true;
		return false;
	}

	final private boolean jj_3R_39() {
		if (jj_3R_43())
			return true;
		return false;
	}

	final private boolean jj_3R_45() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_46()) {
			jj_scanpos = xsp;
			if (jj_3R_47())
				return true;
		}
		return false;
	}

	final private boolean jj_3R_59() {
		if (jj_scan_token(FLOATING_POINT_LITERAL))
			return true;
		return false;
	}

	final private boolean jj_3R_33() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_scan_token(15)) {
			jj_scanpos = xsp;
			if (jj_scan_token(16)) {
				jj_scanpos = xsp;
				if (jj_scan_token(18)) {
					jj_scanpos = xsp;
					if (jj_scan_token(19)) {
						jj_scanpos = xsp;
						if (jj_scan_token(21)) {
							jj_scanpos = xsp;
							if (jj_scan_token(22)) {
								jj_scanpos = xsp;
								if (jj_scan_token(24)) {
									jj_scanpos = xsp;
									if (jj_scan_token(14)) {
										jj_scanpos = xsp;
										if (jj_scan_token(17)) {
											jj_scanpos = xsp;
											if (jj_scan_token(20)) {
												jj_scanpos = xsp;
												if (jj_scan_token(23)) {
													jj_scanpos = xsp;
													if (jj_scan_token(25))
														return true;
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
		xsp = jj_scanpos;
		if (jj_3R_41())
			jj_scanpos = xsp;
		return false;
	}

	final private boolean jj_3R_38() {
		if (jj_scan_token(79))
			return true;
		return false;
	}

	final private boolean jj_3R_58() {
		if (jj_scan_token(INTEGER_LITERAL))
			return true;
		return false;
	}

	final private boolean jj_3R_37() {
		if (jj_scan_token(78))
			return true;
		return false;
	}

	final private boolean jj_3_2() {
		if (jj_3R_33())
			return true;
		if (jj_scan_token(58))
			return true;
		return false;
	}

	final private boolean jj_3R_36() {
		if (jj_scan_token(65))
			return true;
		return false;
	}

	final private boolean jj_3R_56() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_58()) {
			jj_scanpos = xsp;
			if (jj_3R_59()) {
				jj_scanpos = xsp;
				if (jj_3R_60()) {
					jj_scanpos = xsp;
					if (jj_3R_61()) {
						jj_scanpos = xsp;
						if (jj_3R_62())
							return true;
					}
				}
			}
		}
		return false;
	}

	final private boolean jj_3R_67() {
		if (jj_scan_token(67))
			return true;
		return false;
	}

	final private boolean jj_3R_35() {
		if (jj_scan_token(64))
			return true;
		return false;
	}

	final private boolean jj_3_5() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_35()) {
			jj_scanpos = xsp;
			if (jj_3R_36()) {
				jj_scanpos = xsp;
				if (jj_3R_37()) {
					jj_scanpos = xsp;
					if (jj_3R_38())
						return true;
				}
			}
		}
		if (jj_3R_39())
			return true;
		return false;
	}

	final private boolean jj_3R_55() {
		if (jj_scan_token(55))
			return true;
		return false;
	}

	final private boolean jj_3_3() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3_2())
			jj_scanpos = xsp;
		if (jj_3R_34())
			return true;
		if (jj_scan_token(58))
			return true;
		return false;
	}

	final private boolean jj_3R_54() {
		if (jj_3R_57())
			return true;
		return false;
	}

	final private boolean jj_3R_44() {
		if (jj_3R_45())
			return true;
		return false;
	}

	final private boolean jj_3R_42() {
		if (jj_scan_token(60))
			return true;
		return false;
	}

	final private boolean jj_3_6() {
		if (jj_scan_token(IDENTIFIER))
			return true;
		if (jj_3R_40())
			return true;
		return false;
	}
	public ExDesignTreeParserTokenManager token_source;
	JavaCharStream jj_input_stream;
	public Token token, jj_nt;
	private int jj_ntk;
	private Token jj_scanpos, jj_lastpos;
	private int jj_la;
	public boolean lookingAhead = false;
	private boolean jj_semLA;
	private int jj_gen;
	final private int[] jj_la1 = new int[80];
	static private int[] jj_la1_0;
	static private int[] jj_la1_1;
	static private int[] jj_la1_2;
	static {
		jj_la1_0();
		jj_la1_1();
		jj_la1_2();
	}

	private static void jj_la1_0() {
		jj_la1_0 = new int[] { 0x80000000, 0x8000, 0x23ffc000, 0x23ffc000,
				0x23ffc000, 0x0, 0x0, 0x0, 0x0, 0x23ffc000, 0x23ffc000,
				0x40000, 0x200000, 0x1000000, 0x8000000, 0x0, 0x4000000, 0x0,
				0x4000000, 0x8000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x3ffc000, 0x0, 0x3ffc000, 0x3ffc000, 0x0, 0x0, 0x40000,
				0x40000, 0x0, 0x200000, 0x200000, 0x0, 0x1000000, 0x1000000,
				0x0, 0x0, 0x3ffc000, 0x0, 0x3ffc000, 0x3ffc000, 0x3ffc000,
				0x3ffc000, 0x0, 0x3ffc000, 0x0, 0x3ffc000, 0x3ffc000, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x3ffc000, 0x0, 0x3ffc000, 0x0, 0xb0002000,
				0x0, 0x0, 0x0, };
	}

	private static void jj_la1_1() {
		jj_la1_1 = new int[] { 0x0, 0x0, 0x80, 0x0, 0x80, 0x20080, 0x20080,
				0x500000, 0x20000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20000, 0x500000,
				0x20000, 0x500000, 0x0, 0x0, 0x4000000, 0x2f, 0x2f, 0x50,
				0x500000, 0x50, 0x1000000, 0x20000, 0x1000000, 0x20000, 0x0,
				0x10000000, 0x10000000, 0x80, 0x80, 0x10000000, 0x80, 0x80,
				0x10000000, 0x80, 0x80, 0x10000000, 0x1000000, 0x40832700,
				0x1000000, 0x60832700, 0x40832700, 0x60832700, 0x32700,
				0x1000000, 0x32700, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20000000, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x832700, 0x12700, 0x820000, 0x12700, 0x2f, 0x50,
				0x20000, 0x40012700, };
	}

	private static void jj_la1_2() {
		jj_la1_2 = new int[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc0007d,
				0x0, 0xc0007d, 0xc0007d, 0xc0007d, 0x7c, 0x0, 0x7c, 0x1c, 0x1c,
				0x1c, 0x60, 0x60, 0x0, 0x80, 0x100, 0x200, 0x400, 0x800,
				0x3000, 0x3000, 0xc003, 0x70000, 0x70000, 0x60, 0x60, 0x380000,
				0x380000, 0xc00060, 0xc0007c, 0x0, 0x1c, 0x0, 0x0, 0x0, 0x0,
				0x60, };
	}
	final private JJCalls[] jj_2_rtns = new JJCalls[6];
	private boolean jj_rescan = false;
	private int jj_gc = 0;

	public ExDesignTreeParser(java.io.InputStream stream) {
		this(stream, null);
	}

	public ExDesignTreeParser(java.io.InputStream stream, String encoding) {
		try {
			jj_input_stream = new JavaCharStream(stream, encoding, 1, 1);
		} catch (java.io.UnsupportedEncodingException e) {
			throw new RuntimeException(e);
		}
		token_source = new ExDesignTreeParserTokenManager(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 80; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	public void ReInit(java.io.InputStream stream) {
		ReInit(stream, null);
	}

	public void ReInit(java.io.InputStream stream, String encoding) {
		try {
			jj_input_stream.ReInit(stream, encoding, 1, 1);
		} catch (java.io.UnsupportedEncodingException e) {
			throw new RuntimeException(e);
		}
		token_source.ReInit(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 80; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	public ExDesignTreeParser(java.io.Reader stream) {
		jj_input_stream = new JavaCharStream(stream, 1, 1);
		token_source = new ExDesignTreeParserTokenManager(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 80; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	public void ReInit(java.io.Reader stream) {
		jj_input_stream.ReInit(stream, 1, 1);
		token_source.ReInit(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 80; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	public ExDesignTreeParser(ExDesignTreeParserTokenManager tm) {
		token_source = tm;
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 80; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	public void ReInit(ExDesignTreeParserTokenManager tm) {
		token_source = tm;
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 80; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	final private Token jj_consume_token(int kind) throws ParseException {
		Token oldToken;
		if ((oldToken = token).next != null)
			token = token.next;
		else
			token = token.next = token_source.getNextToken();
		jj_ntk = -1;
		if (token.kind == kind) {
			jj_gen++;
			if (++jj_gc > 100) {
				jj_gc = 0;
				for (int i = 0; i < jj_2_rtns.length; i++) {
					JJCalls c = jj_2_rtns[i];
					while (c != null) {
						if (c.gen < jj_gen)
							c.first = null;
						c = c.next;
					}
				}
			}
			return token;
		}
		token = oldToken;
		jj_kind = kind;
		throw generateParseException();
	}
	static private final class LookaheadSuccess extends java.lang.Error {
	}
	final private LookaheadSuccess jj_ls = new LookaheadSuccess();

	final private boolean jj_scan_token(int kind) {
		if (jj_scanpos == jj_lastpos) {
			jj_la--;
			if (jj_scanpos.next == null) {
				jj_lastpos = jj_scanpos = jj_scanpos.next = token_source
						.getNextToken();
			} else {
				jj_lastpos = jj_scanpos = jj_scanpos.next;
			}
		} else {
			jj_scanpos = jj_scanpos.next;
		}
		if (jj_rescan) {
			int i = 0;
			Token tok = token;
			while (tok != null && tok != jj_scanpos) {
				i++;
				tok = tok.next;
			}
			if (tok != null)
				jj_add_error_token(kind, i);
		}
		if (jj_scanpos.kind != kind)
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			throw jj_ls;
		return false;
	}

	final public Token getNextToken() {
		if (token.next != null)
			token = token.next;
		else
			token = token.next = token_source.getNextToken();
		jj_ntk = -1;
		jj_gen++;
		return token;
	}

	final public Token getToken(int index) {
		Token t = lookingAhead ? jj_scanpos : token;
		for (int i = 0; i < index; i++) {
			if (t.next != null)
				t = t.next;
			else
				t = t.next = token_source.getNextToken();
		}
		return t;
	}

	final private int jj_ntk() {
		if ((jj_nt = token.next) == null)
			return (jj_ntk = (token.next = token_source.getNextToken()).kind);
		else
			return (jj_ntk = jj_nt.kind);
	}
	private java.util.Vector jj_expentries = new java.util.Vector();
	private int[] jj_expentry;
	private int jj_kind = -1;
	private int[] jj_lasttokens = new int[100];
	private int jj_endpos;

	private void jj_add_error_token(int kind, int pos) {
		if (pos >= 100)
			return;
		if (pos == jj_endpos + 1) {
			jj_lasttokens[jj_endpos++] = kind;
		} else if (jj_endpos != 0) {
			jj_expentry = new int[jj_endpos];
			for (int i = 0; i < jj_endpos; i++) {
				jj_expentry[i] = jj_lasttokens[i];
			}
			boolean exists = false;
			for (java.util.Enumeration e = jj_expentries.elements(); e
					.hasMoreElements();) {
				int[] oldentry = (int[]) (e.nextElement());
				if (oldentry.length == jj_expentry.length) {
					exists = true;
					for (int i = 0; i < jj_expentry.length; i++) {
						if (oldentry[i] != jj_expentry[i]) {
							exists = false;
							break;
						}
					}
					if (exists)
						break;
				}
			}
			if (!exists)
				jj_expentries.addElement(jj_expentry);
			if (pos != 0)
				jj_lasttokens[(jj_endpos = pos) - 1] = kind;
		}
	}

	public ParseException generateParseException() {
		jj_expentries.removeAllElements();
		boolean[] la1tokens = new boolean[88];
		for (int i = 0; i < 88; i++) {
			la1tokens[i] = false;
		}
		if (jj_kind >= 0) {
			la1tokens[jj_kind] = true;
			jj_kind = -1;
		}
		for (int i = 0; i < 80; i++) {
			if (jj_la1[i] == jj_gen) {
				for (int j = 0; j < 32; j++) {
					if ((jj_la1_0[i] & (1 << j)) != 0) {
						la1tokens[j] = true;
					}
					if ((jj_la1_1[i] & (1 << j)) != 0) {
						la1tokens[32 + j] = true;
					}
					if ((jj_la1_2[i] & (1 << j)) != 0) {
						la1tokens[64 + j] = true;
					}
				}
			}
		}
		for (int i = 0; i < 88; i++) {
			if (la1tokens[i]) {
				jj_expentry = new int[1];
				jj_expentry[0] = i;
				jj_expentries.addElement(jj_expentry);
			}
		}
		jj_endpos = 0;
		jj_rescan_token();
		jj_add_error_token(0, 0);
		int[][] exptokseq = new int[jj_expentries.size()][];
		for (int i = 0; i < jj_expentries.size(); i++) {
			exptokseq[i] = (int[]) jj_expentries.elementAt(i);
		}
		return new ParseException(token, exptokseq, tokenImage);
	}

	final public void enable_tracing() {
	}

	final public void disable_tracing() {
	}

	final private void jj_rescan_token() {
		jj_rescan = true;
		for (int i = 0; i < 6; i++) {
			try {
				JJCalls p = jj_2_rtns[i];
				do {
					if (p.gen > jj_gen) {
						jj_la = p.arg;
						jj_lastpos = jj_scanpos = p.first;
						switch (i) {
						case 0:
							jj_3_1();
							break;
						case 1:
							jj_3_2();
							break;
						case 2:
							jj_3_3();
							break;
						case 3:
							jj_3_4();
							break;
						case 4:
							jj_3_5();
							break;
						case 5:
							jj_3_6();
							break;
						}
					}
					p = p.next;
				} while (p != null);
			} catch (LookaheadSuccess ls) {
			}
		}
		jj_rescan = false;
	}

	final private void jj_save(int index, int xla) {
		JJCalls p = jj_2_rtns[index];
		while (p.gen > jj_gen) {
			if (p.next == null) {
				p = p.next = new JJCalls();
				break;
			}
			p = p.next;
		}
		p.gen = jj_gen + xla - jj_la;
		p.first = token;
		p.arg = xla;
	}
	static final class JJCalls {
		int gen;
		Token first;
		int arg;
		JJCalls next;
	}
}
